{"status":{},"contains_secrets":true,"product_version":"3.5.2","spec":{"description":"","resources":{"endpoints_information":[],"endpoint_definition_list":[],"client_attrs":{},"credential_definition_list":[],"runbook":{"task_definition_list":[{"retries":"0","description":"","inherit_target":false,"child_tasks_local_reference_list":[{"kind":"app_task","name":"Validate Parameters"},{"kind":"app_task","name":"Enable Leap If Disabled"},{"kind":"app_task","name":"Add Accounts"},{"kind":"app_task","name":"Create Protection Policy"},{"kind":"app_task","name":"Create Recovery Plan"}],"name":"edf171c8_dag","attrs":{"edges":[{"from_task_reference":{"kind":"app_task","name":"Add Accounts"},"edge_type":"user_defined","type":"","to_task_reference":{"kind":"app_task","name":"Create Protection Policy"}},{"from_task_reference":{"kind":"app_task","name":"Create Protection Policy"},"edge_type":"user_defined","type":"","to_task_reference":{"kind":"app_task","name":"Create Recovery Plan"}},{"from_task_reference":{"kind":"app_task","name":"Enable Leap If Disabled"},"edge_type":"user_defined","type":"","to_task_reference":{"kind":"app_task","name":"Add Accounts"}},{"from_task_reference":{"kind":"app_task","name":"Validate Parameters"},"edge_type":"user_defined","type":"","to_task_reference":{"kind":"app_task","name":"Enable Leap If Disabled"}}],"type":""},"timeout_secs":"0","type":"DAG","variable_list":[]},{"retries":"0","description":"","inherit_target":false,"child_tasks_local_reference_list":[],"name":"Validate Parameters","attrs":{"exit_status":[],"script":"# script\nimport requests\nfrom requests.auth import HTTPBasicAuth\n\nPC_IP = \"@@{PC_IP}@@\".strip()\npc_user = \"@@{prism_central_username}@@\".strip()\npc_password = \"@@{prism_central_passwd}@@\".strip()\ndr_username = \"@@{dr_account_username}@@\".strip()\ndr_password = \"@@{dr_account_password}@@\".strip()\nDR_PC_IP = \"@@{dr_account_url}@@\".strip()\n\ndef _build_url(scheme, resource_type, host=PC_IP, **params):\n    _base_url = \"\/api\/nutanix\/v3\"\n    url = \"{proto}:\/\/{host}\".format(proto=scheme, host=host)\n    port = params.get('nutanix_port', '9440')\n    if port:\n        url = url + \":{0}\".format(port) + _base_url\n    if resource_type.startswith(\"\/\"):\n        url += resource_type\n    else:\n        url += \"\/{0}\".format(resource_type)\n    return url\n    \ndef get_vm_uuid(vm):\n    url = _build_url(scheme=\"https\",\n                    resource_type=\"\/ngt\/list\")\n    data = requests.post(url, json={\"kind\":\"ngt\"},\n                        auth=HTTPBasicAuth(pc_user,pc_password),\n                        timeout=None, verify=False)\n    if data.ok:\n        for _vm in data.json()[\"entities\"]:\n            uuid = _vm[\"vm_uuid\"]\n            _url = _build_url(scheme=\"https\",\n                             resource_type=\"\/vms\/%s\"%uuid)\n            _data = requests.get(_url,auth=HTTPBasicAuth(pc_user,pc_password),\n                                 timeout=None, verify=False)\n            if _data.ok:\n                if _data.json()[\"spec\"][\"name\"] == vm:\n                    if _vm[\"network_configuration\"][0][\"ip_info_list\"][0][\"ip_type\"] == \"STATIC\": \n                        return _data.json()[\"metadata\"][\"uuid\"]\n                    else:\n                        print(\"%s VM has not static IP configured. VM Should\"\\\n                            \" have Static IP configured for Static IP Mapping.\"%vm)\n                        exit(1)\n        print(\"Input Error :- %s VM is not present or NGT is not installed properly on VM.\"%vm)\n        exit(1)\n    else:\n        print(\"Error while fetching VM details :- \",data.json())\n        exit(1)\n        \ndef _get_subnet_details(subnet, PC, user, password):\n    url = _build_url(scheme=\"https\",host=PC, resource_type=\"\/subnets\/list\")\n    data = requests.post(url, json={\"kind\":\"subnet\", \"filter\":\"name==%s\"%subnet},\n                         auth=HTTPBasicAuth(user, password),\n                         timeout=None, verify=False)\n    subnet_uuid = \"\"\n    if data.ok:\n        if data.json()['metadata']['total_matches'] == 0:\n            print(\"%s not present on %s\"%(subnet, PC_IP))\n            exit(1)\n        elif data.json()['metadata']['total_matches'] > 1:\n            print(\"There are more than one subnets with name - %s on - %s\"%(subnet, PC_IP))\n            print(\"Please delete it manually before executing runbook.\")\n            exit(1)\n        else:\n            subnet_uuid = data.json()['entities'][0]['metadata']['uuid']\n    else:\n        print(\"Error while fetching %s subnet details :- \"%subnet,data.json().get('message_list',\n                                     data.json().get('error_detail', data.json())))\n        exit(1)\n        \n    url = _build_url(scheme=\"https\", host=PC, resource_type=\"\/subnets\/%s\"%subnet_uuid)\n    data = requests.get(url, auth=HTTPBasicAuth(user, password), verify=False)\n    if data.ok:\n        if \"ip_config\" in data.json()[\"spec\"][\"resources\"].keys():\n            gateway = data.json()[\"spec\"][\"resources\"][\"ip_config\"][\"default_gateway_ip\"]\n            prefix = data.json()[\"spec\"][\"resources\"][\"ip_config\"][\"prefix_length\"]\n            return gateway,prefix\n        else:\n            return \"NA\", \"NA\"\n    else:\n        print(\"Error while fetching subnet details :- \",data.json().get('message_list',\n                                     data.json().get('error_detail', data.json())))\n        exit(1)    \n        \ndef _get_cluster_details(cluster_name, host, username, password):\n    payload = {\"kind\": \"cluster\"}\n    url = _build_url(scheme=\"https\", host=host,\n                    resource_type=\"\/clusters\/list\")\n    data = requests.post(url, json=payload,\n                         auth=HTTPBasicAuth(username,password), \n                         verify=False)\n    if data.ok:\n        for _cluster in data.json()['entities']:\n            if _cluster['status']['name'] == cluster_name:\n                return _cluster['metadata']['uuid']\n        print(\"Input Error :- Given cluster %s not present on %s\"%(cluster_name, host))\n        exit(1)\n    else:\n        print(\"Error while fetching %s cluster info\"%cluster_name)\n        print(data.json().get('message_list',data.json().get('error_detail', data.json())))\n        exit(1) \n        \nprimary_cluster_uuid = _get_cluster_details(cluster_name = \"@@{primary_account_cluster}@@\",\n                                            host=PC_IP, username=pc_user, password=pc_password)\nrecovery_cluster_uuid = _get_cluster_details(cluster_name = \"@@{dr_account_cluster}@@\".strip(),\n                                             host=\"@@{dr_account_url}@@\".strip(), \n                                             username=\"@@{dr_account_username}@@\".strip(), \n                                             password=\"@@{dr_account_password}@@\".strip())\n\nprint(\"primary_cluster_uuid={}\".format(primary_cluster_uuid))\nprint(\"recovery_cluster_uuid={}\".format(recovery_cluster_uuid))\n\ncategory = @@{vm_category}@@\npolicy_category = {}\nfor x in category.keys():\n    policy_category[x] = [category[x]]\n\ndr_account_items = {\n                    \"url\" : \"@@{dr_account_url}@@\".strip(),\n                    \"username\" : \"@@{dr_account_username}@@\".strip(),\n                    \"passwd\" : \"@@{dr_account_password}@@\".strip(),\n                    \"sync_interval_secs\" : 3500\n                    }\n\nprint(\"dr_account_items={}\".format(dr_account_items))\n\nprotection_policy_items = {\n                            'name': \"@@{protection_policy_name}@@\".strip(),\n                            'source_az': \"@@{PC_IP}@@\".strip(),\n                            'dest_az': \"@@{dr_account_url}@@\".strip(),\n                            'vm_category':policy_category\n                           }\nprint(\"protection_policy_items={}\".format(protection_policy_items))\n\nIP1, prefix1 = _get_subnet_details(\"@@{primary_network_prod_name}@@\".strip(),PC_IP, pc_user, pc_password)\nIP2, prefix2 = _get_subnet_details(\"@@{primary_network_test_name}@@\".strip(),PC_IP, pc_user, pc_password)\nIP3, prefix3 = _get_subnet_details(\"@@{dr_network_prod_name}@@\".strip(),DR_PC_IP, dr_username, dr_password)\nIP4, prefix4 = _get_subnet_details(\"@@{dr_network_test_name}@@\".strip(),DR_PC_IP, dr_username, dr_password)\n\nrecovery_plan_items = {\n                        'name' : \"@@{recovery_plan_name}@@\".strip(),\n                        'power_on_sequence' : category,\n                        'recovery_network_prod' : {'name' : \"@@{primary_network_prod_name}@@\".strip(),\n                                                   'gateway' : IP1,\n                                                   'prifix' : prefix1\n                        },\n                        'recovery_network_test' : {'name' : \"@@{primary_network_test_name}@@\".strip(),\n                                                   'gateway' : IP2,\n                                                   'prifix' : prefix2\n                        },\n                        'dr_network_prod' : {'name' : \"@@{dr_network_prod_name}@@\".strip(),\n                                             'gateway' : IP3,\n                                             'prifix' : prefix3\n                        },\n                        'dr_network_test' : {'name' : \"@@{dr_network_test_name}@@\".strip(),\n                                             'gateway' : IP4,\n                                             'prifix' : prefix4\n                        }\n                      }\nprint(\"recovery_plan_items={}\".format(recovery_plan_items))\n\nif (@@{static_ip_mapping}@@) and (\"@@{vm_name}@@\".strip().lower() not in [\"\", \"none\", \"na\"]):\n    VM = \"@@{vm_name}@@\".strip()\n    primary_prod = \"@@{primary_network_prod_static_ip}@@\".strip().split(\",\")\n    primary_test = \"@@{primary_network_test_static_ip}@@\".strip().split(\",\")\n    dr_prod = \"@@{dr_network_prod_static_ip}@@\".strip().split(\",\")\n    dr_test = \"@@{dr_network_test_static_ip}@@\".strip().split(\",\")\n    for x in VM.split(\",\"):\n        uuid = get_vm_uuid(x.strip())\n    for x in [primary_prod, primary_test, dr_prod, dr_test]:\n        if len(VM.split(\",\")) != len(x):\n            print(\"Input Error :- Please provide proper static IP mapping between VM's list and %s\"%x)\n            print(\"Number of quama separated VM's should be equal to number of Primary Network Prod Static IP,\" \\\n                      \"Primary Network Test Static IP, DR Network Prod Static IP, DR Network Test Static IP\")\n            exit(1)\n        \ndelay = @@{stage_delay}@@\nreplication = @@{custom_rpo_interval_replication}@@\nif replication < 1:\n    print(\"custom_rpo_interval_replication=1\")\n    print(\"Info : Replication RPO Interval is less than '1' hence using default value of '1'.\")\n    \nlocal = @@{custom_rpo_interval_local}@@\nif local < 1:\n    if @@{local_schedule}@@:\n        print(\"custom_rpo_interval_local=1\")\n        print(\"Info : Local RPO Interval is less than '1' hence using default value of '1'.\")\n        \nretention = @@{number_of_snapshot_retention}@@\nif retention < 1:\n    print(\"number_of_snapshot_retention=1\")\n    print(\"Info : Number of Snapshot Retention is less than '1' hence using default value of '1'.\")\n\ntime = \"@@{policy_schedule_time}@@\".strip()\nif time != \"Immediate\":\n    if \":\" in time:\n        t1, t2 = time.split(\":\")\n        try:\n            if (t1[-1] != \"h\") or (t2[-1] != \"m\"):\n                print(\"Input Error :- Please provide 'Policy Schedule Time From Now' in Proper format.\")\n                print(\"Example :- 10h:30m\")\n                exit(1)\n            hours = int(t1[:-1])\n            minutes = int(t2[:-1])\n            if not hours:\n                hours = \"00\"\n            if minutes:\n                print(\"policy_schedule_time={}\".format(\"@@{policy_schedule_time}@@\".strip()))\n            else:\n                print(\"policy_schedule_time={}\".format(\"@@{policy_schedule_time}@@\".strip()))\n        except Exception as ValueError:\n            print(\"Input Error :- Please provide 'Policy Schedule Time From Now' in Proper format.\")\n            print(\"Example :- 10h:30m\")\n            exit(1)\n    else:\n        print(\"Input Error :- Please provide 'Policy Schedule Time From Now' in below format.\")\n        print(\"Example :- 10h:30m\")\n        exit(1)\n    ","eval_variables":["dr_account_items","protection_policy_items","recovery_plan_items","primary_cluster_uuid","recovery_cluster_uuid","custom_rpo_interval_local","custom_rpo_interval_replication","number_of_snapshot_retention","policy_schedule_time"],"eval_scope":"local","type":"","script_type":"static"},"timeout_secs":"0","type":"SET_VARIABLE","variable_list":[]},{"retries":"0","description":"","inherit_target":false,"child_tasks_local_reference_list":[],"name":"Enable Leap If Disabled","attrs":{"script":"# script\nimport requests\nfrom requests.auth import HTTPBasicAuth\n\nPC_IP = \"@@{PC_IP}@@\".strip()\npc_user = \"@@{prism_central_username}@@\".strip()\npc_password = \"@@{prism_central_passwd}@@\".strip()\n\ndef _build_url(scheme, resource_type, host=PC_IP, **params):\n    _base_url = \"\/api\/nutanix\/v3\"\n    url = \"{proto}:\/\/{host}\".format(proto=scheme, host=host)\n    port = params.get('nutanix_port', '9440')\n    if port:\n        url = url + \":{0}\".format(port) + _base_url\n    if resource_type.startswith(\"\/\"):\n        url += resource_type\n    else:\n        url += \"\/{0}\".format(resource_type)\n    return url\n\ndef enable_leap(host_pc, pc_user, pc_password):\n    url = _build_url(scheme=\"https\",\n                     resource_type=\"\/services\/disaster_recovery\",\n                     host=host_pc)\n    data = requests.post(url, json={\"state\":\"ENABLE\"},\n                        auth=HTTPBasicAuth(pc_user,pc_password),\n                        timeout=None, verify=False)\n    if data.status_code == 409:\n        print(\"Leap is already enabled on %s\"%host_pc)\n    elif data.ok:\n        print(\"Leap Enabled Successfully on %s\"%host_pc)\n    else:\n        print(\"Failed to Enable Leap on %s\"%host_pc)\n\nparams = @@{dr_account_items}@@\nDR_PC = params['url']\nDR_user = params['username']\nDR_password = params['passwd']\nenable_leap(host_pc=PC_IP, pc_user=pc_user, pc_password=pc_password)\nenable_leap(host_pc=DR_PC, pc_user=DR_user, pc_password=DR_password)","type":"","command_line_args":"","exit_status":[],"script_type":"static"},"timeout_secs":"0","type":"EXEC","variable_list":[]},{"retries":"0","description":"","inherit_target":false,"child_tasks_local_reference_list":[],"name":"Add Accounts","attrs":{"exit_status":[],"script":"# script\nimport requests\nfrom requests.auth import HTTPBasicAuth\n\nPC_IP = \"@@{PC_IP}@@\".strip()\npc_user = \"@@{prism_central_username}@@\".strip()\npc_password = \"@@{prism_central_passwd}@@\".strip()\n\ndef _build_url(scheme, resource_type, host=PC_IP, **params):\n    _base_url = \"\/api\/nutanix\/v3\"\n    url = \"{proto}:\/\/{host}\".format(proto=scheme, host=host)\n    port = params.get('nutanix_port', '9440')\n    if port:\n        url = url + \":{0}\".format(port) + _base_url\n    if resource_type.startswith(\"\/\"):\n        url += resource_type\n    else:\n        url += \"\/{0}\".format(resource_type)\n    return url\n\ndef get_spec(**params):\n    return (\n    {\n     \"spec\": {\n        \"name\": \"PC_%s\"%params['url'],\n        \"resources\": {\n            \"url\": params['url'],\n            \"username\": params['username'],\n            \"password\": params['passwd'],\n            \"cloud_type\": params.get(\"cloud_type\", \"ONPREM_CLOUD\")\n        },\n        \"description\": \"\"\n    },\n    \"metadata\": {\n      \"kind\": \"cloud_trust\"\n    },\n    \"api_version\": \"3.1.0\"\n    })\n\ndef get_spec_account(**params):\n    return (\n   {\n    \"api_version\": \"3.0\",\n    \"metadata\": {\n        \"kind\": \"account\"\n    },\n    \"spec\": {\n        \"name\": params.get('name', \"DR_%s\"%params['url'].split(\".\")[-1]),\n        \"resources\": {\n             \"type\": params.get(\"pc_type\", \"nutanix_pc\"),\n            \"data\": {\n                \"server\": params['url'],\n                \"username\": params['username'],\n                \"password\": {\n                    \"value\": params['passwd'],\n                \"attrs\": {\n                    \"is_secret_modified\": True\n                    }\n                }\n            },\n            \"sync_interval_secs\": params.get(\"sync_interval_secs\", 3600)\n            }\n        }\n    })\n  \ndef create_connection(PC=None, user=None, password=None,**params):\n    payload = get_spec(**params)\n    url = _build_url(scheme=\"https\",resource_type=\"\/cloud_trusts\")\n    _user = pc_user\n    _password = pc_password\n    _PC=PC_IP\n    if PC != None:\n        url = _build_url(scheme=\"https\",host=PC, resource_type=\"\/cloud_trusts\")\n        _user = user\n        _password = password\n        _PC=PC\n    data = requests.post(url, json=payload,\n                        auth=HTTPBasicAuth(_user,_password),\n                        timeout=None, verify=False)\n    wait_for_completion(data, _PC, _user, _password)\n    \n    _url = _build_url(scheme=\"https\",resource_type=\"\/groups\")\n    _payload = {\n        \"entity_type\": \"availability_zone_physical\",\n        \"grouping_attribute\": \"type\",\n        \"group_member_count\": 1,\n        \"group_member_attributes\": [\n            {\n                \"attribute\": \"name\"\n            },\n            {\n                \"attribute\": \"url\"\n            }\n        ],\n        \"query_name\": \"prism:BaseGroupModel\"}\n        \n    _data = requests.post(_url, json=_payload,\n                             auth=HTTPBasicAuth(_user,_password),\n                             timeout=None, verify=False)\n    az_uuid = \"\"\n    print(_data.json())\n    print(params['url'])\n    if _data.ok:\n        if params['url'] in str(_data.json()):\n            for cloud_trust in _data.json()[\"group_results\"]:\n                if cloud_trust[\"entity_results\"][0][\"data\"][0][\"values\"][0][\"values\"][0] == \"PC_\"+params['url']:\n                    az_uuid = cloud_trust[\"entity_results\"][0][\"data\"][1][\"values\"][0][\"values\"][0]\n        else:\n            print(\"%s PC's availability zone not present on %s\"%(params['url'], PC_IP))\n            exit(1)\n    else:\n        print(\"Failed to retrive Availability Zone information.\")\n        print(data.json())\n        exit(1)\n    print(\"dest_az_uuid={}\".format(az_uuid))\n    \ndef add_account(PC=None, user=None, password=None, **params):\n    payload = get_spec_account(**params)\n    url = _build_url(scheme=\"https\",resource_type=\"\/accounts\")\n    _user = pc_user\n    _password = pc_password\n    _PC=PC_IP\n    if PC != None:\n        url = _build_url(scheme=\"https\",host=PC, resource_type=\"\/accounts\")\n        _user = user\n        _password = password\n        _PC=PC\n    data = requests.post(url, json=payload,\n                        auth=HTTPBasicAuth(_user,_password),\n                        timeout=None, verify=False)\n    if \"DUPLICATE_ACCOUNT\" in str(data.json()):\n        print(\"Input Error :- Your provided account url - %s is \"\\\n              \"already a part of another account\"%params['url'])\n        _url = _build_url(scheme=\"https\",resource_type=\"\/accounts\/%s\"%data.json()[\"metadata\"][\"uuid\"])\n        _data = requests.delete(_url,auth=HTTPBasicAuth(_user,_password),timeout=None, verify=False)\n        if _data.ok:\n            exit(1)\n        else:\n            print(\"Getting error while deleting %s account.\"%payload[\"spec\"][\"name\"])\n            print(_data.json())\n            exit(1)\n    wait_for_completion(data, _PC, _user, _password)\n    \ndef wait_for_completion(data, PC=None, user=None, password=None):\n    if data.ok:\n        state = data.json()['status'].get('state')\n        while state == \"PENDING\":\n            _uuid = data.json()['status']['execution_context']['task_uuid']\n            url = _build_url(scheme=\"https\",\n                             resource_type=\"\/tasks\/%s\"%_uuid)\n            _user = pc_user\n            _password = pc_password\n            if PC != None:\n                url = _build_url(scheme=\"https\", host=PC,\n                             resource_type=\"\/tasks\/%s\"%_uuid)\n                _user = user\n                _password = password\n            responce = requests.get(url, auth=HTTPBasicAuth(_user,_password),\n                                    verify=False)                      \n            if responce.json()['status'] in ['PENDING', 'RUNNING', 'QUEUED']:\n                state = 'PENDING'\n                sleep(5)                \n            elif responce.json()['status'] == 'FAILED':\n                if (\"DUPLICATE_CLOUD_TRUST\" in str(responce.json())) or (\"DUPLICATE_NAME\" in str(responce.json())):\n                    pass\n                else:\n                    print(\"Got Error ---> \",responce.json().get('message_list', \n                                            responce.json().get('error_detail', responce.json())))\n                    state = 'FAILED'\n                    exit(1)\n            else:\n                state = \"COMPLETE\"\n    else:\n        if (\"DUPLICATE_CLOUD_TRUST\" in str(data.json())) or (\"DUPLICATE_NAME\" in str(data.json())):\n            pass\n        else:\n            print(\"Got Error ---> \",data.json().get('message_list', \n                                    data.json().get('error_detail', data.json())))\n            exit(1)\n\n# Create account and connection at local PC\nparams = @@{dr_account_items}@@\ncreate_connection(**params)\n#add_account(**params)\n\n# Create account and connection at DR PC\n#_params = {\"name\" : \"Production_%s\"%PC_IP.split(\".\")[-1],\n#          \"url\" : PC_IP,\n#          \"username\" : pc_user,\n#          \"passwd\" : pc_password,\n#          \"sync_interval_secs\" : params.get(\"sync_interval_secs\", 3600)}\n#add_account(PC=params['url'], \n#            user=params['username'],\n#            password=params['passwd'],\n#            **_params)","eval_variables":["dest_az_uuid"],"eval_scope":"local","type":"","script_type":"static"},"timeout_secs":"0","type":"SET_VARIABLE","variable_list":[]},{"retries":"0","description":"","inherit_target":false,"child_tasks_local_reference_list":[],"name":"Create Protection Policy","attrs":{"exit_status":[],"script":"# script\nimport requests\nfrom requests.auth import HTTPBasicAuth\n\nPC_IP = \"@@{PC_IP}@@\".strip()\npc_user = \"@@{prism_central_username}@@\".strip()\npc_password = \"@@{prism_central_passwd}@@\".strip()\n\ndef _build_url(scheme, resource_type, host=PC_IP, **params):\n    _base_url = \"\/api\/nutanix\/v3\"\n    url = \"{proto}:\/\/{host}\".format(proto=scheme, host=host)\n    port = params.get('nutanix_port', '9440')\n    if port:\n        url = url + \":{0}\".format(port) + _base_url\n    if resource_type.startswith(\"\/\"):\n        url += resource_type\n    else:\n        url += \"\/{0}\".format(resource_type)\n    return url\n\ndef get_spec(**params):\n    rpo_time_replication = int(@@{custom_rpo_interval_replication}@@) * 60 * 60\n    if @@{custom_rpo_interval_replication}@@ <= 1:\n        rpo_time_replication = 3600\n        \n    category_filter = {}\n    for x in params[\"vm_category\"]:\n        category_filter[x] = params[\"vm_category\"][x]\n    return (\n    {\"spec\": {\n        \"name\": params['name'],\n        \"resources\": {\n            \"ordered_availability_zone_list\": [\n                {\n                    \"availability_zone_url\": params[\"source_az_uuid\"],\n                    \"cluster_uuid\": \"@@{primary_cluster_uuid}@@\".strip()\n                },\n                {\n                    \"availability_zone_url\": params[\"dest_az_uuid\"],\n                    \"cluster_uuid\": \"@@{recovery_cluster_uuid}@@\".strip()\n                }\n            ],\n            \"availability_zone_connectivity_list\": [\n                {\n                    \"source_availability_zone_index\": 0,\n                    \"destination_availability_zone_index\": 1,\n                    \"snapshot_schedule_list\": [\n                        {\n                            \"recovery_point_objective_secs\": rpo_time_replication,\n                            \"snapshot_type\": params.get(\"snapshot_type\",\"CRASH_CONSISTENT\"),\n                            \"local_snapshot_retention_policy\": {\n                                \"num_snapshots\": int(@@{number_of_snapshot_retention}@@)\n                            },\n                            \"remote_snapshot_retention_policy\": {\n                                \"num_snapshots\": int(@@{number_of_snapshot_retention}@@)\n                            }\n                        }\n                    ]\n                },\n                {\n                    \"source_availability_zone_index\": 1,\n                    \"destination_availability_zone_index\": 0,\n                    \"snapshot_schedule_list\": [\n                        {\n                            \"recovery_point_objective_secs\": rpo_time_replication,\n                            \"snapshot_type\": params.get(\"snapshot_type\",\"CRASH_CONSISTENT\"),\n                            \"local_snapshot_retention_policy\": {\n                                \"num_snapshots\": int(@@{number_of_snapshot_retention}@@)\n                            },\n                            \"remote_snapshot_retention_policy\": {\n                                \"num_snapshots\": int(@@{number_of_snapshot_retention}@@)\n                            }\n                        }\n                    ]\n                }\n            ],\n            \"category_filter\": {\"params\":category_filter},\n            \"primary_location_list\": [\n                0\n            ]\n        }\n    },\n    \"metadata\": {\n        \"kind\": \"protection_rule\"\n    },\n    \"api_version\": \"3.1.0\"\n    })\n\ndef local_schedule(_index, **params):\n    rpo_time_local = int(@@{custom_rpo_interval_local}@@) * 60 * 60\n    if @@{custom_rpo_interval_local}@@ <= 1:\n        rpo_time_local = 3600\n    return {\n                \"source_availability_zone_index\": _index,\n                \"snapshot_schedule_list\": [\n                    {\n                        \"recovery_point_objective_secs\": rpo_time_local,\n                        \"snapshot_type\": params.get(\"snapshot_type\",\"CRASH_CONSISTENT\"),\n                        \"local_snapshot_retention_policy\": {\n                            \"num_snapshots\": int(@@{number_of_snapshot_retention}@@)\n                        }\n                    }\n                ]\n            }\n            \ndef create_protection_policy(**params):\n    params['source_az_uuid'] = get_account_info(\"Local AZ\")\n    params['dest_az_uuid'] = \"@@{dest_az_uuid}@@\".strip()\n    \n    print(\"source_az_uuid={}\".format(params['source_az_uuid']))\n    payload = get_spec(**params)\n    if @@{local_schedule}@@:\n        payload['spec']['resources']['availability_zone_connectivity_list'].append(local_schedule(_index=0))\n        payload['spec']['resources']['availability_zone_connectivity_list'].append(local_schedule(_index=1))\n    if \"@@{policy_schedule_time}@@\".strip() != \"Immediate\":\n        payload['spec']['resources']['start_time'] = \"@@{policy_schedule_time}@@\".strip()\n    url = _build_url(scheme=\"https\",resource_type=\"\/protection_rules\")\n    data = requests.post(url, json=payload,\n                        auth=HTTPBasicAuth(pc_user,pc_password),\n                        timeout=None, verify=False)    \n    wait_for_completion(data)\n    if data.ok:\n        _uuid = data.json()['metadata']['uuid']\n        batch_call(_uuid)\n\ndef wait_for_completion(data):\n    if data.ok:\n        state = data.json()['status'].get('state')\n        while state == \"PENDING\":\n            _uuid = data.json()['status']['execution_context']['task_uuid']\n            url = _build_url(scheme=\"https\",\n                             resource_type=\"\/tasks\/%s\"%_uuid)\n            responce = requests.get(url, auth=HTTPBasicAuth(pc_user,pc_password), \n                                    verify=False)                      \n            if responce.json()['status'] in ['PENDING', 'RUNNING', 'QUEUED']:\n                state = 'PENDING'\n                sleep(5)                \n            elif responce.json()['status'] == 'FAILED':\n                print(\"Error ---> \",responce.json().get('message_list', \n                                        responce.json().get('error_detail', responce.json())))\n                state = 'FAILED'\n                exit(1)\n            else:\n                state = \"COMPLETE\"\n    else:\n        print(\"Error ---> \",data.json().get('message_list', \n                                data.json().get('error_detail', data.json())))\n        exit(1)\n\ndef batch_call(entity_uuid):\n    payload = {\n                \"action_on_failure\": \"CONTINUE\",\n                \"execution_order\": \"NON_SEQUENTIAL\",\n                \"api_request_list\": [\n                    {\n                        \"operation\": \"POST\",\n                        \"path_and_params\": \"\/api\/nutanix\/v3\/groups\",\n                        \"body\": {\n                            \"entity_type\": \"protection_rule\",\n                            \"entity_ids\": [entity_uuid],\n                            \"group_member_attributes\": [\n                                {\n                                    \"attribute\": \"name\"\n                                }\n                            ],\n                            \"query_name\": \"prism:EBQueryModel\"\n                        }\n                    }\n                ],\n                \"api_version\": \"3.0\"\n            }\n    url = _build_url(scheme=\"https\",resource_type=\"\/batch\")\n    data = requests.post(url, json=payload,\n                        auth=HTTPBasicAuth(pc_user,pc_password),\n                        timeout=None, verify=False)\n    if not data.ok:\n        print(\"Got Error ---> \",data.json().get('message_list', \n                                data.json().get('error_detail', data.json())))\n    \ndef get_account_info(az_url):\n    url = _build_url(scheme=\"https\",resource_type=\"\/groups\")\n    payload = {\n        \"entity_type\": \"availability_zone_physical\",\n        \"grouping_attribute\": \"type\",\n        \"group_member_count\": 1,\n        \"group_member_attributes\": [\n            {\n                \"attribute\": \"name\"\n            },\n            {\n                \"attribute\": \"url\"\n            }\n        ],\n        \"query_name\": \"prism:BaseGroupModel\"\n    }\n    \n    data = requests.post(url, json=payload,\n                        auth=HTTPBasicAuth(pc_user,pc_password),\n                        timeout=None, verify=False)\n                        \n    if data.ok:\n        for cloud_trust in data.json()[\"group_results\"]:\n            if cloud_trust[\"entity_results\"][0][\"data\"][0][\"values\"][0][\"values\"][0] == az_url:\n                return cloud_trust[\"entity_results\"][0][\"data\"][1][\"values\"][0][\"values\"][0]\n        print(\"%s availability zone not present on %s\"%(az_url, PC_IP))\n        exit(1)\n    else:\n        print(\"Failed to retrive availability zone info of %s\"%az_url)\n        print(\"Please make sure PC url is correct and rechable.\")\n        print(data.json())\n        exit(1)\n\nparams_dict = @@{protection_policy_items}@@\ncreate_protection_policy(**params_dict)","eval_variables":["source_az_uuid"],"eval_scope":"local","type":"","script_type":"static"},"timeout_secs":"0","type":"SET_VARIABLE","variable_list":[]},{"retries":"0","description":"","inherit_target":false,"child_tasks_local_reference_list":[],"name":"Create Recovery Plan","attrs":{"script":"# script\nimport requests\nfrom requests.auth import HTTPBasicAuth\n\nPC_IP = \"@@{PC_IP}@@\".strip()\npc_user = \"@@{prism_central_username}@@\".strip()\npc_password = \"@@{prism_central_passwd}@@\".strip()\nsource_az_uuid = \"@@{source_az_uuid}@@\".strip()\ndest_az_uuid = \"@@{dest_az_uuid}@@\".strip()\nprotection_policy = @@{protection_policy_items}@@\n\ndef _build_url(scheme, resource_type, host=PC_IP, **params):\n    _base_url = \"\/api\/nutanix\/v3\"\n    url = \"{proto}:\/\/{host}\".format(proto=scheme, host=host)\n    port = params.get('nutanix_port', '9440')\n    if port:\n        url = url + \":{0}\".format(port) + _base_url\n    if resource_type.startswith(\"\/\"):\n        url += resource_type\n    else:\n        url += \"\/{0}\".format(resource_type)\n    return url\n\ndef _get_stage_spec(vm_category):\n    url = _build_url(scheme=\"https\",\n                    resource_type=\"\/idempotence_identifiers\")\n    data = requests.post(url, json={\"count\": 1,\"valid_duration_in_minutes\": 527040},\n                        auth=HTTPBasicAuth(pc_user,pc_password),\n                        timeout=None, verify=False)                   \n    _uuid = \"\"\n    if data.ok:\n        _uuid = data.json()['uuid_list'][0]\n    else:\n        print(\"Failed to generate idemotence uuid, Please try again ...\")\n        exit(1)\n        \n    return ({\n            \"stage_work\": {\n                \"recover_entities\": {\n                    \"entity_info_list\": [\n                        {\n                            \"categories\": vm_category,\n                            \"script_list\": [{\n                              \"enable_script_exec\": @@{enable_boot_script}@@\n                            }]\n                        }\n                    ]\n                }\n            },\n            \"stage_uuid\": _uuid,\n            \"delay_time_secs\": @@{stage_delay}@@\n        })\n  \ndef get_spec(**params):\n    stage_list = []\n    for vm_category in params['power_on_sequence'].keys():\n        _category = {vm_category:params['power_on_sequence'][vm_category]}\n        stage_list.append(_get_stage_spec(_category))\n    recovery_network = False\n    if \"@@{recovery_network_type}@@\" == \"stretched\":\n        recovery_network = True\n    return (\n    {\"spec\": {\n        \"name\": params['name'],\n        \"resources\": {\n            \"stage_list\": stage_list,\n            \"parameters\": {\n                \"primary_location_index\": 0,\n                \"availability_zone_list\": [\n                    {\n                        \"availability_zone_url\": source_az_uuid,\n                        \"cluster_reference_list\": []\n                    },\n                    {\n                        \"availability_zone_url\": dest_az_uuid,\n                        \"cluster_reference_list\": []\n                    }\n                ],\n                \"network_mapping_list\": [\n                    {\n                        \"are_networks_stretched\": recovery_network,\n                        \"availability_zone_network_mapping_list\": [\n                            {\n                                \"recovery_network\": {\n                                    \"name\": params['recovery_network_prod']['name']\n                                },\n                                \"availability_zone_url\": source_az_uuid,\n                                \"test_network\": {\n                                    \"name\": params['recovery_network_test']['name']\n                                }\n                            },\n                            {\n                                \"recovery_network\": {\n                                    \"name\": params['dr_network_prod']['name']\n                                },\n                                \"availability_zone_url\": dest_az_uuid,\n                                \"test_network\": {\n                                    \"name\": params['dr_network_test']['name']\n                                }\n                            }\n                        ]\n                    }\n                ],\n                \"floating_ip_assignment_list\": []\n            }\n        },\n        \"description\": params.get('description', '')\n    },\n    \"metadata\": {\n        \"kind\": \"recovery_plan\",\n        \"spec_version\": 0\n    },\n    \"api_version\": \"3.1.0\"\n    })\n\ndef get_static_map_spec(IP, vm):\n    return ({\n      \"vm_reference\": {\n          \"kind\": \"vm\",\n          \"name\": vm,\n          \"uuid\": get_vm_uuid(vm)\n          },\n      \"ip_config_list\": [{\n          \"ip_address\": IP.strip()\n          }\n       ]})\n  \ndef subnet_list_spec(network, **params):\n    return [{\n             \"external_connectivity_state\": \"DISABLED\",\n              \"gateway_ip\": params[network]['gateway'],\n              \"prefix_length\": int(params[network]['prifix'])\n             }]\n  \ndef create_recovery_plan(**params):\n    payload = get_spec(**params)\n    recovery_prod = []\n    recovery_dr = []\n    test_prod = []\n    test_dr = []\n    if @@{static_ip_mapping}@@:\n        for x,_vm in enumerate(params[\"vm_name\"].split(\",\")):\n            recovery_prod.append(get_static_map_spec(\"@@{primary_network_prod_static_ip}@@\".strip().split(\",\")[x], _vm.strip()))\n            recovery_dr.append(get_static_map_spec(\"@@{dr_network_prod_static_ip}@@\".strip().split(\",\")[x], _vm.strip()))\n            test_prod.append(get_static_map_spec(\"@@{primary_network_test_static_ip}@@\".strip().split(\",\")[x], _vm.strip()))\n            test_dr.append(get_static_map_spec(\"@@{dr_network_test_static_ip}@@\".strip().split(\",\")[x], _vm.strip()))\n            \n        payload[\"spec\"][\"resources\"][\"parameters\"][\"network_mapping_list\"][0]\\\n               [\"availability_zone_network_mapping_list\"][0]\\\n               [\"recovery_ip_assignment_list\"] = recovery_prod\n        payload[\"spec\"][\"resources\"][\"parameters\"][\"network_mapping_list\"][0]\\\n               [\"availability_zone_network_mapping_list\"][0]\\\n               [\"test_ip_assignment_list\"] = test_prod\n        payload[\"spec\"][\"resources\"][\"parameters\"][\"network_mapping_list\"][0]\\\n               [\"availability_zone_network_mapping_list\"][1]\\\n               [\"recovery_ip_assignment_list\"] = recovery_dr\n        payload[\"spec\"][\"resources\"][\"parameters\"][\"network_mapping_list\"][0]\\\n               [\"availability_zone_network_mapping_list\"][1]\\\n               [\"test_ip_assignment_list\"] = test_dr\n        \n    if params[\"recovery_network_prod\"][\"gateway\"] != \"NA\":\n        _spec = subnet_list_spec(network=\"recovery_network_prod\", **params)\n        payload[\"spec\"][\"resources\"][\"parameters\"][\"network_mapping_list\"][0]\\\n            [\"availability_zone_network_mapping_list\"][0][\"recovery_network\"]\\\n            [\"subnet_list\"] = _spec\n        \n    if params[\"recovery_network_test\"][\"gateway\"] != \"NA\":\n        _spec = subnet_list_spec(network=\"recovery_network_test\", **params)\n        payload[\"spec\"][\"resources\"][\"parameters\"][\"network_mapping_list\"][0]\\\n            [\"availability_zone_network_mapping_list\"][0][\"test_network\"]\\\n            [\"subnet_list\"] = _spec\n        \n    if params[\"dr_network_prod\"][\"gateway\"] != \"NA\":\n        _spec = subnet_list_spec(network=\"dr_network_prod\", **params)\n        payload[\"spec\"][\"resources\"][\"parameters\"][\"network_mapping_list\"][0]\\\n            [\"availability_zone_network_mapping_list\"][1][\"recovery_network\"]\\\n            [\"subnet_list\"] = _spec\n        \n    if params[\"dr_network_test\"][\"gateway\"] != \"NA\":\n        _spec = subnet_list_spec(network=\"dr_network_test\", **params)\n        payload[\"spec\"][\"resources\"][\"parameters\"][\"network_mapping_list\"][0]\\\n            [\"availability_zone_network_mapping_list\"][1][\"test_network\"]\\\n            [\"subnet_list\"] = _spec\n        \n    url = _build_url(scheme=\"https\",resource_type=\"\/recovery_plans\")\n    data = requests.post(url, json=payload,\n                        auth=HTTPBasicAuth(pc_user,pc_password),\n                        timeout=None, verify=False)\n    wait_for_completion(data)\n    print(\"SUCCESS !!!\")\n\ndef wait_for_completion(data):\n    if data.ok:\n        state = data.json()['status'].get('state')\n        while state == \"PENDING\":\n            _uuid = data.json()['status']['execution_context']['task_uuid']\n            url = _build_url(scheme=\"https\",\n                             resource_type=\"\/tasks\/%s\"%_uuid)\n            responce = requests.get(url, auth=HTTPBasicAuth(pc_user,pc_password), \n                                    verify=False)                      \n            if responce.json()['status'] in ['PENDING', 'RUNNING', 'QUEUED']:\n                state = 'PENDING'\n                sleep(5)                \n            elif responce.json()['status'] == 'FAILED':\n                print(\"Error while creating Recovery plan ---> \",responce.json().get('message_list', \n                                        responce.json().get('error_detail', responce.json())))\n                state = 'FAILED'\n                exit(1)\n            else:\n                state = \"COMPLETE\"\n    else:\n        print(\"Error while creating recovery plan ---> \",data.json().get('message_list', \n                                data.json().get('error_detail', data.json())))\n        exit(1)\n\ndef get_vm_uuid(vm):\n    url = _build_url(scheme=\"https\",\n                    resource_type=\"\/ngt\/list\")\n    data = requests.post(url, json={\"kind\":\"ngt\"},\n                        auth=HTTPBasicAuth(pc_user,pc_password),\n                        timeout=None, verify=False)\n    if data.ok:\n        for _vm in data.json()[\"entities\"]:\n            uuid = _vm[\"vm_uuid\"]\n            _url = _build_url(scheme=\"https\",\n                             resource_type=\"\/vms\/%s\"%uuid)\n            _data = requests.get(_url,auth=HTTPBasicAuth(pc_user,pc_password),\n                                 timeout=None, verify=False)\n            if _data.ok:\n                if _data.json()[\"spec\"][\"name\"] == vm:\n                    if _vm[\"network_configuration\"][0][\"ip_info_list\"][0][\"ip_type\"] == \"STATIC\": \n                        return _data.json()[\"metadata\"][\"uuid\"]\n                    else:\n                        print(\"%s VM has not static IP configured. VM Should\"\\\n                            \" have Static IP configured for Static IP Mapping.\"%vm)\n                        exit(1)\n        print(\"Input Error :- %s VM is not present or NGT is not installed properly on VM.\"%vm)\n        exit(1)\n    else:\n        print(\"Error while fetching VM details :- \",data.json())\n        exit(1)\n        \nparams_dict = @@{recovery_plan_items}@@\nparams_dict[\"vm_name\"] = \"@@{vm_name}@@\".strip()\ncreate_recovery_plan(**params_dict)","type":"","command_line_args":"","exit_status":[],"script_type":"static"},"timeout_secs":"0","type":"EXEC","variable_list":[]}],"description":"","name":"fd79599d_runbook","main_task_local_reference":{"kind":"app_task","name":"edf171c8_dag"},"variable_list":[{"val_type":"STRING","is_mandatory":true,"description":"","data_type":"BASE","type":"LOCAL","name":"protection_policy_name","value":"Green_DR_Policy","label":"Protection Policy Name","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":true,"description":"","data_type":"BASE","type":"LOCAL","name":"recovery_plan_name","value":"Green_Recovery_plan","label":"Recovery Plan Name","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"regex":{"should_validate":false,"value":"^[\\d]*$"},"val_type":"INT","is_mandatory":true,"description":"Default 1 Hour.","data_type":"BASE","type":"LOCAL","name":"custom_rpo_interval_replication","value":"1","label":"Custom RPO Interval for Replication in Hours","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":true,"description":"Local schedule at primary and recovery PC.","data_type":"BASE","type":"LOCAL","name":"local_schedule","value":"True","label":"Local Schedule","attrs":{"type":"LOCAL"},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":["True","False"]}},{"regex":{"should_validate":false,"value":"^[\\d]*$"},"val_type":"INT","is_mandatory":true,"description":"Should be >= 1 for \"Local Schedule = True\"","data_type":"BASE","type":"LOCAL","name":"custom_rpo_interval_local","value":"1","label":"Custom RPO Interval for Local Snapshot in Hours","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"regex":{"should_validate":false,"value":"^[\\d]*$"},"val_type":"INT","is_mandatory":true,"description":"","data_type":"BASE","type":"LOCAL","name":"number_of_snapshot_retention","value":"1","label":"Retention on Primary and Remote","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":true,"description":"Immediate or <xx>h:<yy>m","data_type":"BASE","type":"LOCAL","name":"policy_schedule_time","value":"Immediate","label":"Protection Start Time","attrs":{"type":"LOCAL"},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":true,"description":"","data_type":"BASE","type":"LOCAL","name":"primary_account_cluster","value":"PHX-POC092","label":"Primary Account Cluster Name","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":true,"description":"","data_type":"BASE","type":"LOCAL","name":"PC_IP","value":"10.42.92.21","label":"Primary PC IP","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":true,"description":"","data_type":"BASE","type":"SECRET","name":"prism_central_username","value":"ofcVSrE5h+Dw4h4jLu0pQ74VqBYyiUh4fwZJd1EBj5R7f0Selw==:utf-8","label":"Primary PC Username","attrs":{"is_secret_modified":false,"secret_reference":{},"type":"SECRET"},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":true,"description":"","data_type":"BASE","type":"SECRET","name":"prism_central_passwd","value":"Yc4G+7q6MuXj34RDzywGA6h4+MTJMxhskn0AQp4exEqi869R6oaUhB4lOw==:utf-8","label":"Primary PC Password","attrs":{"is_secret_modified":false,"secret_reference":{},"type":"SECRET"},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":true,"description":"","data_type":"BASE","type":"LOCAL","name":"dr_account_cluster","value":"PHX-POC100","label":"DR Account Cluster Name","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":true,"description":"","data_type":"BASE","type":"LOCAL","name":"dr_account_url","value":"10.42.100.21","label":"DR PC IP","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":true,"description":"","data_type":"BASE","type":"SECRET","name":"dr_account_username","value":"O5qL2Ks0NDvwY5LBNjWQX95NVJj324HOwSiucnStXcSzGvVvDQ==:utf-8","label":"DR PC Username","attrs":{"is_secret_modified":false,"secret_reference":{},"type":"SECRET"},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":true,"description":"","data_type":"BASE","type":"SECRET","name":"dr_account_password","value":"m9vyVEEf\/U9whFK3AhW\/2LmIlQi89twQEz3ic7spBeNoZQmy0qMTTykTEg==:utf-8","label":"DR PC Password","attrs":{"is_secret_modified":false,"secret_reference":{},"type":"SECRET"},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":true,"description":"Example :- {\"Key\" : \"Value\"}","data_type":"BASE","type":"LOCAL","name":"vm_category","value":"{\"TenantName\": \"Tmp\"}","label":"VM Category for Protection Policy and Recovery Plan","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":true,"description":"","data_type":"BASE","type":"LOCAL","name":"recovery_network_type","value":"non-stretched","label":"Recovery Plan Network Type","attrs":{"type":"LOCAL"},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":["stretched","non-stretched"]}},{"regex":{"should_validate":false,"value":"^[\\d]*$"},"val_type":"INT","is_mandatory":true,"description":"Delay in stages for recovery plan ( boot order  )","data_type":"BASE","type":"LOCAL","name":"stage_delay","value":"0","label":"Stage Delay [ In Seconds ]","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"regex":{"should_validate":false,"value":"^.*$"},"val_type":"STRING","is_mandatory":true,"description":"","data_type":"BASE","type":"LOCAL","name":"enable_boot_script","value":"False","label":"Enable Boot Script ","attrs":{"type":"LOCAL"},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":["True","False"]}},{"val_type":"STRING","is_mandatory":true,"description":"","data_type":"BASE","type":"LOCAL","name":"primary_network_prod_name","value":"Green_Overlay_Subnet","label":"Primary Network Name - Production Subnet","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":true,"description":"","data_type":"BASE","type":"LOCAL","name":"primary_network_test_name","value":"Green_Overlay_Subnet","label":"Primary Network Name - Test Subnet","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":true,"description":"","data_type":"BASE","type":"LOCAL","name":"dr_network_prod_name","value":"Test_DR","label":"DR Network Name - Production Subnet","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":true,"description":"","data_type":"BASE","type":"LOCAL","name":"dr_network_test_name","value":"Test_DR","label":"DR Network Name - Test Subnet","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":true,"description":"","data_type":"BASE","type":"LOCAL","name":"static_ip_mapping","value":"False","label":"Enable Static IP Mapping ","attrs":{"type":"LOCAL"},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":["False","True"]}},{"val_type":"STRING","is_mandatory":false,"description":"Example :- VM1, VM2","data_type":"BASE","type":"LOCAL","name":"vm_name","value":"NA","label":"VM Name","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":false,"description":"Example :- 10.10.10.2,10.10.10.3","data_type":"BASE","type":"LOCAL","name":"primary_network_prod_static_ip","value":"NA","label":"Primary Network Prod Static IP","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":false,"description":"Example :- 10.10.10.2,10.10.10.3","data_type":"BASE","type":"LOCAL","name":"primary_network_test_static_ip","value":"NA","label":"Primary Network Test Static IP","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":false,"description":"Example :- 10.10.10.2,10.10.10.3","data_type":"BASE","type":"LOCAL","name":"dr_network_prod_static_ip","value":"NA","label":"DR Network Prod Static IP","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":false,"description":"Example :- 10.10.10.2,10.10.10.3","data_type":"BASE","type":"LOCAL","name":"dr_network_test_static_ip","value":"NA","label":"DR Network Test Static IP","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}}]}},"name":"Leap DR"},"api_version":"3.0","metadata":{"last_update_time":"1665641535065424","kind":"runbook","spec_version":28,"creation_time":"1665574388294813","name":"Leap DR"}}