{"status":{},"contains_secrets":true,"product_version":"3.5.0","spec":{"description":"","resources":{"endpoints_information":[],"endpoint_definition_list":[],"client_attrs":{},"credential_definition_list":[],"runbook":{"task_definition_list":[{"retries":"0","description":"","inherit_target":false,"child_tasks_local_reference_list":[{"kind":"app_task","name":"Parameters Validation"},{"kind":"app_task","name":"Generate Tenant UID"},{"kind":"app_task","name":"Create IDP If not Added"},{"kind":"app_task","name":"Create Categories"},{"kind":"app_task","name":"Create External Subnet"},{"kind":"app_task","name":"Create VPC"},{"kind":"app_task","name":"Create Overlay Subnet"},{"kind":"app_task","name":"Create Project"},{"kind":"app_task","name":"Create Tunnel for VPC"},{"kind":"app_task","name":"Set Quota"},{"kind":"app_task","name":"Create Environment"},{"kind":"app_task","name":"Update Project"}],"name":"8ee0af0e_dag","attrs":{"edges":[{"from_task_reference":{"kind":"app_task","name":"Parameters Validation"},"edge_type":"user_defined","type":"","to_task_reference":{"kind":"app_task","name":"Generate Tenant UID"}},{"from_task_reference":{"kind":"app_task","name":"Create External Subnet"},"edge_type":"user_defined","type":"","to_task_reference":{"kind":"app_task","name":"Create VPC"}},{"from_task_reference":{"kind":"app_task","name":"Create VPC"},"edge_type":"user_defined","type":"","to_task_reference":{"kind":"app_task","name":"Create Overlay Subnet"}},{"from_task_reference":{"kind":"app_task","name":"Generate Tenant UID"},"edge_type":"user_defined","type":"","to_task_reference":{"kind":"app_task","name":"Create Categories"}},{"from_task_reference":{"kind":"app_task","name":"Create Environment"},"edge_type":"user_defined","type":"","to_task_reference":{"kind":"app_task","name":"Update Project"}},{"from_task_reference":{"kind":"app_task","name":"Set Quota"},"edge_type":"user_defined","type":"","to_task_reference":{"kind":"app_task","name":"Create Environment"}},{"from_task_reference":{"kind":"app_task","name":"Create Tunnel for VPC"},"edge_type":"user_defined","type":"","to_task_reference":{"kind":"app_task","name":"Set Quota"}},{"from_task_reference":{"kind":"app_task","name":"Create Project"},"edge_type":"user_defined","type":"","to_task_reference":{"kind":"app_task","name":"Create Tunnel for VPC"}},{"from_task_reference":{"kind":"app_task","name":"Create Overlay Subnet"},"edge_type":"user_defined","type":"","to_task_reference":{"kind":"app_task","name":"Create Project"}},{"from_task_reference":{"kind":"app_task","name":"Create IDP If not Added"},"edge_type":"user_defined","type":"","to_task_reference":{"kind":"app_task","name":"Create External Subnet"}},{"from_task_reference":{"kind":"app_task","name":"Generate Tenant UID"},"edge_type":"user_defined","type":"","to_task_reference":{"kind":"app_task","name":"Create IDP If not Added"}}],"type":""},"timeout_secs":"0","type":"DAG","variable_list":[]},{"retries":"0","description":"","inherit_target":false,"child_tasks_local_reference_list":[],"name":"Parameters Validation","attrs":{"exit_status":[],"script":"# script\n\nimport requests\nfrom requests.auth import HTTPBasicAuth\n\nPC_IP = \"@@{PC_IP}@@\"\npc_username = \"@@{prism_central_username}@@\"\npc_password = \"@@{prism_central_passwd}@@\"\nskip_delete = False\n\ndef _build_url(scheme, resource_type, host=PC_IP, **params):\n    _base_url = \"\/api\/nutanix\/v3\"\n    url = \"{proto}:\/\/{host}\".format(proto=scheme, host=host)\n    port = params.get('nutanix_port', '9440')\n    if port:\n        url = url + \":{0}\".format(port) + _base_url\n    if resource_type.startswith(\"\/\"):\n        url += resource_type\n    else:\n        url += \"\/{0}\".format(resource_type)\n    return url\n\ndef _get_cluster_details(cluster_name):\n    payload = {\"kind\": \"cluster\"}\n    url = _build_url(scheme=\"https\",\n                    resource_type=\"\/clusters\/list\")\n    data = requests.post(url, json=payload,\n                         auth=HTTPBasicAuth(pc_username, pc_password), \n                         verify=False)\n    if data.ok:\n        for _cluster in data.json()['entities']:\n            if _cluster['status']['name'] == cluster_name:\n                print(\"cluster_uuid={}\".format(_cluster['metadata']['uuid']))\n                return str(_cluster['metadata']['uuid'])\n        print(\"Input Error :- Given cluster %s not present on %s\"%(cluster_name, PC_IP))\n        exit(1)\n    else:\n        print(\"Error while fetching %s cluster info\"%cluster_name)\n        print(data.json().get('message_list',data.json().get('error_detail', data.json())))\n        exit(1)\n            \ndef _get_virtual_switch_uuid(virtual_switch_name, cluster_uuid): \n    payload = {\"entity_type\": \"distributed_virtual_switch\", \n               \"filter\": \"name==%s\"%virtual_switch_name}\n    url = _build_url(scheme=\"https\",\n                    resource_type=\"\/groups\")                \n    data = requests.post(url, json=payload,\n                         auth=HTTPBasicAuth(pc_username, pc_password),\n                         verify=False)\n    if data.ok:\n        _uuid = data.json()['group_results'][0]['entity_results'][0]['entity_id']\n        _url = \"https:\/\/%s:9440\/api\/networking\/v2.a1\/dvs\/virtual-switches\/%s?proxyClusterUuid=%s\"%(PC_IP,\n                                                                                                _uuid,\n                                                                                                cluster_uuid)\n        _data = requests.get(_url, auth=HTTPBasicAuth(pc_username, pc_password),verify=False)\n        if _data.json()['data']['name'] == virtual_switch_name:\n            print(\"virtual switch uuid ----> \",_uuid)\n            return str(_uuid)\n        else:\n            print(\"Input Error :- %s virtual switch not present on %s\"%(virtual_switch_name, PC_IP))\n            exit(1)\n    else:\n        print(\"Error while fetching virtual switch details :- \",data.json().get('message_list',\n                                                                                data.json().get('error_detail', \n                                                                                data.json())))\n\ndef _get_subnet_uuid(subnet, delete=False):\n    global skip_delete\n    url = _build_url(scheme=\"https\",resource_type=\"\/subnets\/list\")\n    data = requests.post(url, json={\"kind\":\"subnet\", \"filter\":\"name==%s\"%subnet},\n                         auth=HTTPBasicAuth(pc_username, \n                                            pc_password),\n                         timeout=None, verify=False)\n    if data.ok:\n        if data.json()['metadata']['total_matches'] == 0:\n            print(\"%s not present on %s\"%(subnet, PC_IP))\n            skip_delete = True\n            if not delete:\n                exit(1)\n        elif data.json()['metadata']['total_matches'] > 1:\n            print(\"There are more than one subnets with name - %s on - %s\"%(subnet, PC_IP))\n            print(\"Please delete it manually before executing runbook.\")\n            exit(1)\n        else:\n            skip_delete = False\n            return data.json()['entities'][0]['metadata']['uuid']\n    else:\n        print(\"Error while fetching subnet details :- \",data.json().get('message_list',\n                                     data.json().get('error_detail', data.json())))\n        exit(1)\n        \ndef get_subnet_details(_uuid):\n    url = _build_url(scheme=\"https\",resource_type=\"\/subnets\/%s\"%_uuid)\n    data = requests.get(url, auth=HTTPBasicAuth(pc_username, pc_password),\n                        timeout=None, verify=False)\n    if not data.ok:\n        print(\"Error while fetching project subnet details.\")\n        print(data.json().get('message_list',\\\n            data.json().get('error_detail', data.json())))\n        exit(1)\n    else:\n        print(\"project_subnet_address={}\".format(data.json()['spec']\\\n            ['resources']['ip_config']['pool_list'][0]['range'].split( )[-1]))\n        \ndef _get_vpc_uuid(vpc_name):\n    global skip_delete\n    url = _build_url(scheme=\"https\",resource_type=\"\/vpcs\/list\")\n    data = requests.post(url, json={\"kind\":\"vpc\", \"filter\":\"name==%s\"%vpc_name},\n                         auth=HTTPBasicAuth(pc_username, \n                                            pc_password),\n                         timeout=None, verify=False)\n    if data.ok:\n        if data.json()['metadata']['total_matches'] == 0:\n            print(\"%s not present on %s\"%(vpc_name, PC_IP))\n            skip_delete = True\n        elif data.json()['metadata']['total_matches'] > 1:\n            print(\"There are more than one VPC's with name - %s on - %s\"%(vpc_name, PC_IP))\n            print(\"Please delete it manually before executing runbook.\")\n            exit(1)\n        else:\n            skip_delete = False\n            return data.json()['entities'][0]['metadata']['uuid']\n    else:\n        print(\"Error while fetching VPC details :- \",data.json().get('message_list',\n                                     data.json().get('error_detail', data.json())))\n        exit(1)\n        \ndef _get_project_uuid(project_name):\n    global skip_delete\n    url = _build_url(scheme=\"https\",resource_type=\"\/projects\/list\")\n    data = requests.post(url, json={\"kind\":\"project\", \"filter\":\"name==%s\"%project_name},\n                         auth=HTTPBasicAuth(pc_username, \n                                            pc_password),\n                         timeout=None, verify=False)\n    if data.ok:\n        if data.json()['metadata']['total_matches'] == 0:\n            print(\"%s not present on %s\"%(project_name, PC_IP))\n            skip_delete = True\n        elif data.json()['metadata']['total_matches'] > 1:\n            print(\"There are more than one projects with name - %s on - %s\"%(project_name, PC_IP))\n            print(\"Please delete it manually before executing runbook.\")\n            exit(1)\n        else:\n            skip_delete = False\n            return data.json()['entities'][0]['metadata']['uuid']\n    else:\n        print(\"Error while fetching project details :- \",data.json().get('message_list',\n                                     data.json().get('error_detail', data.json())))\n        exit(1)\n\ndef wait_for_completion(data):\n    if data.ok:\n        state = data.json()['status'].get('state')\n        while state == \"DELETE_PENDING\":\n            _uuid = data.json()['status']['execution_context']['task_uuid']\n            url = _build_url(scheme=\"https\",\n                             resource_type=\"\/tasks\/%s\"%_uuid)\n            responce = requests.get(url, auth=HTTPBasicAuth(pc_username, pc_password), \n                                    verify=False)\n            if responce.json()['status'] in ['DELETE_PENDING']:\n                state = 'DELETE_PENDING'\n                sleep(5)                \n            elif responce.json()['status'] == 'FAILED':\n                print(\"Got Error ---> \",responce.json().get('message_list', \n                                        responce.json().get('error_detail', responce.json())))\n                state = 'FAILED'\n                exit(1)\n            else:\n                state = \"COMPLETE\" \n    else:\n        print(\"Got Error ---> \",data.json().get('message_list', \n                                data.json().get('error_detail', data.json())))\n        exit(1)\n        \ndef _get_ip(IP):\n    ip_list = IP.split(\".\")\n    gatewat_digit = int(ip_list[-1]) + 1\n    start_digit = gatewat_digit + 1\n    end_digit = start_digit + 50\n    gateway_ip = ip_list[:3]\n    gateway_ip.append(str(gatewat_digit))\n    gateway_ip = \".\".join(gateway_ip)\n    start_ip = ip_list[:3]\n    start_ip.append(str(start_digit))\n    start_ip = \".\".join(start_ip)\n    end_ip = ip_list[:3]\n    end_ip.append(str(end_digit))\n    end_ip = \".\".join(end_ip)\n    return (gateway_ip, start_ip, end_ip)\n    \nexternal_subnet_items = {}\nvpc_items = {}\noverlay_subnet_items = {}\nproject_items = {}\nAD_items = {}\naccount_items = {}\n\ntenant = \"@@{tenant_name}@@\"\ncluster = \"@@{cluster_name}@@\"\ncluter_uuid = _get_cluster_details(cluster)\nexternal_subnet = \"@@{external_subnet_ip}@@\"\nexternal_subnet_ip, external_subnet_prefix= external_subnet.split(\"\/\")\nexternal_subnet_items['name'] = \"@@{tenant_name}@@_External_Subnet\"\nexternal_subnet_items['cluster'] = cluster\nexternal_subnet_items['enable_nat'] = @@{external_subnet_nat}@@\nexternal_subnet_items['virtual_switch_name'] = \"@@{virtual_switch}@@\"\n_uuid = _get_virtual_switch_uuid(external_subnet_items['virtual_switch_name'], cluter_uuid)\nexternal_subnet_items['gateway_ip'] = \"@@{external_subnet_gateway_ip}@@\"\nexternal_subnet_items['network_ip'] = external_subnet_ip\nexternal_subnet_items['prefix'] = int(external_subnet_prefix)\nIP_POOL = \"@@{external_subnet_ip_pool}@@\".split(\"-\")\nexternal_subnet_items['ip_pools'] = {\"range\":\"%s %s\"%(IP_POOL[0],IP_POOL[1])}\n\nvpc_items['name'] = \"@@{tenant_name}@@_VPC\"\nvpc_items['external_subnet_name'] = external_subnet_items['name']\n\noverlay_subnet = \"@@{overlay_subnet_ip}@@\"\noverlay_subnet_ip, overlay_subnet_prefix = overlay_subnet.split(\"\/\")\noverlay_subnet_items['subnet_name'] = \"@@{tenant_name}@@_Overlay_Subnet\"\noverlay_subnet_items['vpc_name'] = vpc_items['name']\noverlay_subnet_items['network_ip'] = overlay_subnet_ip\noverlay_subnet_items['prefix'] = int(overlay_subnet_prefix)\noverlay_subnet_items['gateway_ip'] = \"@@{overlay_subnet_gateway_ip}@@\"\nIP = _get_ip(overlay_subnet_ip)\noverlay_subnet_items['ip_pool'] = [{\"ip_pools_start_ip\":IP[1], \n                                     \"ip_pools_end_ip\":IP[2]}]\nprint(\"project_subnet_address={}\".format(IP[2]))\n\nadmin_user = \"@@{project_admin_user}@@\"\nproject_subnet_uuid = \"\"\nproject_items['name'] = \"{}_project\".format(tenant)\nproject_items['tenant_users'] =  [{\"admin\": [\"{}\".format(admin_user)]}]\nproject_items['accounts'] = \"@@{account_name}@@\"\nproject_items['allow_collaboration'] = False\n#project_subnet = \"@@{project_subnet_uuid}@@\"\n#get_subnet_details(project_subnet)\n#print(\"project_subnet_uuid={}\".format(project_subnet))\n#project_items['subnets'] = [\"{}\".format(project_subnet)]\nproject_items['quotas'] = [{'storage_gb':@@{project_disk_size}@@,\n                            'mem_gb':@@{project_memory}@@,\n                            'vcpu':@@{project_vcpu}@@}]\n\naccount_items['cluster'] = cluster\naccount_items['quotas'] = [{'storage_gb':@@{project_disk_size}@@,\n                            'mem_gb':@@{project_memory}@@,\n                            'vcpu':@@{project_vcpu}@@}]\n\nprint(\"external_subnet_items={}\".format(external_subnet_items))\nprint(\"vpc_items={}\".format(vpc_items))\nprint(\"overlay_subnet_items={}\".format(overlay_subnet_items))\nprint(\"project_items={}\".format(project_items))\nprint(\"AD_items={}\".format(AD_items))\nprint(\"account_items={}\".format(account_items))\n\ndef _delete(type, uuid):\n    url = _build_url(scheme=\"https\",resource_type=\"\/%s\/%s\"%(type,_uuid))\n    data = requests.delete(url, auth=HTTPBasicAuth(pc_username, pc_password),\n                           timeout=None, verify=False)\n    if not data.ok:\n        print(\"Failed to delete existing %s with uuid %s.\"%(type, uuid))\n        print(\"Error :- \",data.json())\n        exit(1)\n    else:\n        wait_for_completion(data)\n        \nif \"@@{delete_existing}@@\" == \"yes\":\n    _uuid = _get_project_uuid(project_items['name'])\n    if skip_delete == False:\n        _delete(type=\"projects\", uuid=_uuid)\n        \n    _uuid = _get_subnet_uuid(subnet=overlay_subnet_items['subnet_name'], delete=True)\n    if skip_delete == False:\n        _delete(type=\"subnets\", uuid=_uuid)\n        sleep(5)\n    \n    _uuid = _get_vpc_uuid(vpc_items['name'])\n    if skip_delete == False:\n        _delete(type=\"vpcs\", uuid=_uuid)\n        sleep(5)\n        \n    _uuid = _get_subnet_uuid(subnet=external_subnet_items['name'], delete=True)\n    if skip_delete == False:\n        _delete(type=\"subnets\", uuid=_uuid)","eval_variables":["external_subnet_items","vpc_items","overlay_subnet_items","project_items","account_items","cluster_uuid","project_subnet_uuid","project_subnet_address"],"eval_scope":"local","type":"","script_type":"static"},"timeout_secs":"0","type":"SET_VARIABLE","variable_list":[]},{"retries":"0","description":"","inherit_target":false,"child_tasks_local_reference_list":[],"name":"Generate Tenant UID","attrs":{"exit_status":[],"script":"uid = uuid.uuid4()\nprint(\"tenant_uuid={}\".format(uid))\n","eval_variables":["tenant_uuid"],"eval_scope":"local","type":"","script_type":"static"},"timeout_secs":"0","type":"SET_VARIABLE","variable_list":[]},{"retries":"0","description":"","inherit_target":false,"child_tasks_local_reference_list":[],"name":"Create IDP If not Added","attrs":{"exit_status":[],"script":"# script\nimport requests\nfrom requests.auth import HTTPBasicAuth\n\nPC_IP = \"@@{PC_IP}@@\"\npc_user = \"@@{prism_central_username}@@\"\npc_password = \"@@{prism_central_passwd}@@\"\n\n#roles = ROLE_CLUSTER_VIEWER, ROLE_USER_ADMIN, ROLE_CLUSTER_ADMIN\n\ndef _build_url(scheme, resource_type, host=PC_IP, **params):\n    _base_url = \"\/api\/nutanix\/v3\"\n    url = \"{proto}:\/\/{host}\".format(proto=scheme, host=host)\n    port = params.get('nutanix_port', '9440')\n    if port:\n        url = url + \":{0}\".format(port) + _base_url\n    if resource_type.startswith(\"\/\"):\n        url += resource_type\n    else:\n        url += \"\/{0}\".format(resource_type)\n    return url\n    \ndef wait_for_completion(data):\n    if data.ok:\n        state = data.json()['status'].get('state')\n        while state == \"PENDING\":\n            _uuid = data.json()['status']['execution_context']['task_uuid']\n            url = _build_url(scheme=\"https\",\n                             resource_type=\"\/tasks\/%s\"%_uuid)\n            responce = requests.get(url, auth=HTTPBasicAuth(pc_user, pc_password),\n                                    verify=False)                      \n            if responce.json()['status'] in ['PENDING', 'RUNNING', 'QUEUED']:\n                state = 'PENDING'\n                sleep(5)                \n            elif responce.json()['status'] == 'FAILED':\n                print(\"Error occured ---> \",data.json().get('message_list', \n                                        data.json().get('error_detail', data.json())))\n                state = 'FAILED'\n                exit(1)\n            else:\n                state = \"COMPLETE\"\n    else:\n        print(\"Error occured ---> \",data.json().get('message_list', \n                                data.json().get('error_detail', data.json())))\n        exit(1)\n\ndef get_spec():\n    return ({\n              \"spec\":{\n                \"name\":\"@@{idp_name}@@\",\n                \"resources\":{\n                  \"idp_metadata\":\"\"}},\n              \"metadata\":{\n                \"kind\":\"identity_provider\"\n                },\n              \"api_version\":\"3.1.0\"\n            })\n\ndef identity_providers():\n    payload = get_spec()\n    payload[\"spec\"][\"resources\"][\"idp_metadata\"] = \"\"\"@@{idp_metadata}@@\"\"\"\n    url = _build_url(scheme=\"https\",\n                    resource_type=\"\/identity_providers\")\n    data = requests.post(url, json=payload,\n                        auth=HTTPBasicAuth(pc_user,pc_password),\n                        timeout=None, verify=False)\n    wait_for_completion(data)\n    idp_uuid = data.json()[\"metadata\"][\"uuid\"]\n    print(\"idp_details={}\".format({\"name\":\"@@{idp_name}@@\",\n                                   \"uuid\":idp_uuid}))\n    return idp_uuid\n    \n    \ndef create_role_mapping(idp_uuid):\n    query_string = \"&entityType=USER&role=ROLE_CLUSTER_VIEWER\"\n    url = \"https:\/\/%s:9440\/PrismGateway\/services\/rest\/v1\/\"\\\n          \"authconfig\/identity_providers\/%s\/role_mappings?%s\"%(PC_IP,\n                                                              idp_uuid,\n                                                              query_string)\n    payload = {\"role\":\"ROLE_CLUSTER_VIEWER\",\"entityType\":\"USER\",\n               \"idpUuid\":idp_uuid,\n               \"entityValues\":[\"idpuser10@calmsaastest.com\"]}\n    data = requests.post(url, json=payload,\n                        auth=HTTPBasicAuth(pc_user,pc_password),\n                        timeout=None, verify=False)\n    if not data.ok:\n        print(\"Error :- \",data.json())\n        exit(1)\n    print(data.json())\n    \nurl = _build_url(scheme=\"https\",\n                    resource_type=\"\/identity_providers\/list\")\ndata = requests.post(url, json={\"kind\":\"identity_provider\"},\n                        auth=HTTPBasicAuth(pc_user,pc_password),\n                        timeout=None, verify=False)\n\nif data.json()[\"metadata\"][\"total_matches\"] >= 1:\n    for IDP in data.json()[\"entities\"]:\n        if IDP[\"spec\"][\"name\"] == \"@@{idp_name}@@\":\n            print(\"idp_details={}\".format({\"name\":\"@@{idp_name}@@\", \n                                           \"uuid\":IDP[\"metadata\"][\"uuid\"]}))\nelse:\n    idp_uuid = identity_providers()\n    create_role_mapping(idp_uuid)","eval_variables":["idp_details"],"eval_scope":"local","type":"","script_type":"static"},"timeout_secs":"0","type":"SET_VARIABLE","variable_list":[]},{"retries":"0","description":"","inherit_target":false,"child_tasks_local_reference_list":[],"name":"Create Categories","attrs":{"script":"# script\nimport requests\nfrom requests.auth import HTTPBasicAuth\n\nPC_IP = \"@@{PC_IP}@@\"\npc_password = \"@@{prism_central_passwd}@@\"\npc_username = \"@@{prism_central_username}@@\"\n\ntenant = \"@@{tenant_uuid}@@\"\nCategoryName = \"TenantName\"\nvalue = \"@@{tenant_name}@@\"\ndescription = \"Tenant Onboarding category for %s\"%value\n\nbase_url = 'https:\/\/{}:9440\/api\/nutanix\/v3\/categories'.format(PC_IP)\npayload = {\n            \"name\": CategoryName,\n            \"description\": description,\n            \"capabilities\": {\n                \"cardinality\": 64\n            }\n        }\n\napi_url = base_url + '\/' + CategoryName\n\nr = requests.put(api_url, json=payload, \n                 auth=HTTPBasicAuth(pc_username, pc_password),\n                 timeout=None, verify=False)\nif not r.ok:\n    print(\"PUT request failed\", r.content)\n    exit(1)\n\nbatch_url = \"https:\/\/{}:9440\/api\/nutanix\/v3\/batch\".format(PC_IP)\n\npayload = {\"action_on_failure\":\"CONTINUE\",\n                \"execution_order\":\"NON_SEQUENTIAL\",\n                \"api_request_list\":[\n                    {\n                        \"operation\":\"PUT\",\n                        \"path_and_params\":\"\/api\/nutanix\/v3\/categories\/{}\/{}\".format(CategoryName, value),\n                        \"body\":{\n                        \"value\":value,\n                        \"description\":description\n                        }\n                    }\n                    ],\n                    \"api_version\":\"3.0\"}\n\nr = requests.post(batch_url, json=payload, \n                  auth=HTTPBasicAuth(pc_username, pc_password),\n                 timeout=None, verify=False)\nif r.ok:\n    print(\"Category created: {}\".format(CategoryName))\n    print(\"category_details={}\".format(r.content))\nelse:\n    print(\"Failed to create category - %s\"%CategoryName)\n    print(r.content)","type":"","command_line_args":"","exit_status":[],"script_type":"static"},"timeout_secs":"0","type":"EXEC","variable_list":[]},{"retries":"0","description":"","inherit_target":false,"child_tasks_local_reference_list":[],"name":"Create External Subnet","attrs":{"exit_status":[],"script":"#script\n\nimport requests\nfrom requests.auth import HTTPBasicAuth\n\nPC_IP = \"@@{PC_IP}@@\"\npc_username = \"@@{prism_central_username}@@\"\npc_password = \"@@{prism_central_passwd}@@\"\n\ndef _build_url(scheme, resource_type, host=PC_IP, **params):\n    _base_url = \"\/api\/nutanix\/v3\"\n    url = \"{proto}:\/\/{host}\".format(proto=scheme, host=host)\n    port = params.get('nutanix_port', '9440')\n    if port:\n        url = url + \":{0}\".format(port) + _base_url\n    if resource_type.startswith(\"\/\"):\n        url += resource_type\n    else:\n        url += \"\/{0}\".format(resource_type)\n    return url\n  \ndef _get_cluster_details(cluster_name):\n    cluster_details = {'kind':'cluster'}\n    payload = {\"kind\": \"cluster\"}\n    url = _build_url(scheme=\"https\",\n                    resource_type=\"\/clusters\/list\")\n    data = requests.post(url, json=payload,\n                         auth=HTTPBasicAuth(pc_username, pc_password), \n                         verify=False)\n    if data.ok:\n        for _cluster in data.json()['entities']:\n            if _cluster['status']['name'] == cluster_name:\n                cluster_details['uuid'] = str(_cluster['metadata']['uuid'])\n                return cluster_details\n        print(\"Input Error :- Given cluster %s not present on %s\"%(cluster_name, PC_IP))\n        exit(1)\n    else:\n        print(\"Error while fetching %s cluster info\"%cluster_name)\n        print(data.json().get('message_list',data.json().get('error_detail', data.json())))\n        exit(1)\n    \ndef _get_virtual_switch_uuid(virtual_switch_name):\n    cluster = \"@@{cluster_name}@@\"\n    _cluster = _get_cluster_details(cluster)\n    cluster_uuid = _cluster['uuid']\n    payload = {\"entity_type\": \"distributed_virtual_switch\", \n               \"filter\": \"name==%s\"%virtual_switch_name}\n    url = _build_url(scheme=\"https\",\n                    resource_type=\"\/groups\")                \n    data = requests.post(url, json=payload,\n                         auth=HTTPBasicAuth(pc_username, pc_password),\n                         verify=False)\n    if data.ok:\n        _uuid = data.json()['group_results'][0]['entity_results'][0]['entity_id']\n        _url = \"https:\/\/%s:9440\/api\/networking\/v2.a1\/dvs\/virtual-switches\/%s?proxyClusterUuid=%s\"%(PC_IP,\n                                                                                                _uuid,\n                                                                                                cluster_uuid)\n        _data = requests.get(_url, auth=HTTPBasicAuth(pc_username, pc_password),verify=False)\n        if _data.json()['data']['name'] == virtual_switch_name:\n            print(\"virtual switch uuid ----> \",_uuid)\n            return str(_uuid)\n        else:\n            print(\"Input Error :- %s virtual switch not present on %s\"%(virtual_switch_name, PC_IP))\n            exit(1)\n    else:\n        print(\"Error while fetching virtual switch details :- \",data.json().get('message_list',\n                                                                                data.json().get('error_detail', \n                                                                                data.json())))\n\ndef _get_default_spec():\n    return (\n        {\n          \"api_version\": \"3.1.0\",\n          \"metadata\": {\"kind\": \"subnet\"},\n          \"spec\": {\n                  \"name\": \"\",\n                  \"resources\": {\n                      \"ip_config\": {},\n                      \"subnet_type\": None,\n                      },\n                  },\n              }\n          )\n\ndef _get_ipam_spec(**params):\n    ipam_spec = {}\n    if params['set_ipam'] == 'yes':\n        ipam_spec = _get_default_ipconfig_spec()\n        ipam_config = params[\"ipam\"]\n        ipam_spec[\"subnet_ip\"] = ipam_config[\"network_ip\"]\n        ipam_spec[\"prefix_length\"] = ipam_config[\"network_prefix\"]\n        ipam_spec[\"default_gateway_ip\"] = ipam_config[\"gateway_ip\"]\n        pools = []\n        pools.append(params[\"ip_pools\"])\n        ipam_spec[\"pool_list\"] = pools\n    return ipam_spec\n\ndef _get_default_ipconfig_spec():\n    return (\n        {\n         \"subnet_ip\": None,\n         \"prefix_length\": None,\n         \"default_gateway_ip\": None,\n         \"pool_list\": [],\n        }\n      )\n\ndef create_external_subnet(**params):\n    params['ipam_spec'] = _get_ipam_spec(**params)\n    payload = _get_default_spec()\n    if params['uuid'] != \"None\":\n        payload[\"spec\"]['uuid'] = params['uuid']\n    payload[\"spec\"]['name'] = params['name']\n    payload[\"spec\"][\"resources\"][\"subnet_type\"] = \"VLAN\"\n    payload[\"spec\"][\"resources\"][\"vlan_id\"] = params['vlan_id']\n    payload[\"spec\"][\"resources\"][\"ip_config\"] = params['ipam_spec']\n    payload[\"spec\"][\"cluster_reference\"] = params.get('cluser_reference',\\\n                                _get_cluster_details(cluster_name=params['cluster_name']))\n    if params['enable_nat'] == False:\n        params['virtual_switch_uuid'] = params.get('virtual_switch_uuid',\\\n                _get_virtual_switch_uuid(params['virtual_switch_name']))\n        payload[\"spec\"][\"resources\"][\"virtual_switch_uuid\"] = params['virtual_switch_uuid']\n    payload[\"spec\"][\"resources\"][\"is_external\"] = True\n    payload[\"spec\"][\"resources\"][\"enable_nat\"] = params['enable_nat']\n    url = _build_url(scheme=\"https\",\n                        resource_type=\"\/subnets\")\n    while True:\n        data = requests.post(url, json=payload,\n                         auth=HTTPBasicAuth(pc_username, \n                                            pc_password),\n                         timeout=None, verify=False)\n        if data.ok:\n            task_uuid = wait_for_completion(data)\n            task = {\"uuid\": data.json()['metadata']['uuid'],\n                    \"create_subnet_task_uuid\":task_uuid,\n                    \"name\": params['name']}\n            return task\n        elif \"subnet exists with VLAN ID\" in str(data.json()):\n            payload[\"spec\"][\"resources\"][\"vlan_id\"] = params['vlan_id'] + 5\n        else:\n            print(\"Got Error ---> \",data.json().get('message_list', \n                                    data.json().get('error_detail', data.json())))\n            exit(1)\n\ndef wait_for_completion(data):\n    if data.ok:\n        state = data.json()['status'].get('state')\n        while state == \"PENDING\":\n            _uuid = data.json()['status']['execution_context']['task_uuid']\n            url = _build_url(scheme=\"https\",\n                             resource_type=\"\/tasks\/%s\"%_uuid)\n            responce = requests.get(url, auth=HTTPBasicAuth(pc_username, pc_password), \n                                    verify=False)\n            if responce.json()['status'] in ['PENDING', 'RUNNING','QUEUED']:\n                state = 'PENDING'\n                sleep(5)                \n            elif responce.json()['status'] == 'FAILED':\n                print(\"Got Error ---> \",responce.json().get('message_list', \n                                        responce.json().get('error_detail', responce.json())))\n                state = 'FAILED'\n                exit(1)\n            else:\n                state = \"COMPLETE\"\n    return data.json()['status']['execution_context']['task_uuid']\n            \ndef _get_vlan_id():\n    url = _build_url(scheme=\"https\",resource_type=\"\/subnets\/list\")\n    data = requests.post(url, json={\"kind\":\"subnet\"},\n                         auth=HTTPBasicAuth(pc_username, \n                                            pc_password),\n                         timeout=None, verify=False)\n    if data.ok:\n        vlan_id = []\n        for x in data.json()['entities']:\n            print(x['spec']['resources'])\n            vlan_id.append(x['spec']['resources'].get('vlan_id', 0))\n        id = 10\n        while True:\n            if id in vlan_id:\n                id+=1\n            else:\n                break\n        return id\n    else:\n        print(\"Error while fetching subnet list :- \",data.json().get('message_list',\n                                     data.json().get('error_detail', data.json())))\n        exit(1)\ndef validate_params():\n    params = {}\n    subnets = []\n    params_dict = @@{external_subnet_items}@@\n    params['name'] = params_dict['name']\n    params['uuid'] = params_dict.get('uuid', \"None\")\n    params['enable_nat'] = params_dict.get('enable_nat', False)\n    params['cluster_name'] = params_dict.get('cluster', \"None\")\n    params['vlan_id'] = @@{external_vlan_id}@@\n    params['virtual_switch_name'] = params_dict.get('virtual_switch_name', \"None\")\n    params['ipam'] = {}\n    params['set_ipam'] = \"yes\"\n    params['ipam']['network_ip'] = params_dict.get('network_ip', 'None')\n    params['ipam']['network_prefix'] = params_dict.get('prefix', 'None')\n    params['ipam']['gateway_ip'] = params_dict['gateway_ip']\n    params['ip_pools'] = params_dict['ip_pools']\n    subnet = create_external_subnet(**params)\n    subnets.append(subnet)\n    print(\"external_subnet_details={}\".format(subnets))\nvalidate_params()","eval_variables":["external_subnet_details"],"eval_scope":"local","type":"","script_type":"static"},"timeout_secs":"0","type":"SET_VARIABLE","variable_list":[]},{"retries":"0","description":"","inherit_target":false,"child_tasks_local_reference_list":[],"name":"Create VPC","attrs":{"exit_status":[],"script":"#script\n\nimport requests\nfrom requests.auth import HTTPBasicAuth\n\nPC_IP = \"@@{PC_IP}@@\"\npc_username = \"@@{prism_central_username}@@\"\npc_password = \"@@{prism_central_passwd}@@\"\n\ndef _build_url(scheme, resource_type, host=PC_IP, **params):\n    _base_url = \"\/api\/nutanix\/v3\"\n    url = \"{proto}:\/\/{host}\".format(proto=scheme, host=host)\n    port = params.get('nutanix_port', '9440')\n    if port:\n        url = url + \":{0}\".format(port) + _base_url\n    if resource_type.startswith(\"\/\"):\n        url += resource_type\n    else:\n        url += \"\/{0}\".format(resource_type)\n    return url\n\ndef _get_default_spec():\n    return(\n            {\n            \"api_version\": \"3.1.0\",\n            \"metadata\": {\"kind\": \"vpc\", \"categories\": {}},\n            \"spec\": {\n                \"name\": None,\n                \"resources\": {\n                    \"external_subnet_list\": []\n                    },\n                },\n            })\n\ndef create_vpc(**params):\n    payload = _get_default_spec()\n    if params['uuid'] != \"None\":\n        payload[\"spec\"]['uuid'] = params['uuid']\n    payload[\"spec\"]['name'] = params['name']\n    if params.get(\"common_domain_name_server_ip_list\", \"None\") != \"None\":\n        payload[\"spec\"][\"resources\"][\"common_domain_name_server_ip_list\"] = \\\n                                params[\"common_domain_name_server_ip_list\"]\n    payload[\"spec\"][\"resources\"][\"external_subnet_list\"] = \\\n                                params[\"external_subnet_list\"]\n    if params.get(\"externally_routable_prefix_list\", \"None\") != \"None\":\n        payload[\"spec\"][\"resources\"][\"externally_routable_prefix_list\"] = \\\n                                params[\"externally_routable_prefix_list\"]\n    url = _build_url(scheme=\"https\",\n                        resource_type=\"\/vpcs\")    \n    data = requests.post(url, json=payload,\n                         auth=HTTPBasicAuth(pc_username, pc_password ),\n                         timeout=None, verify=False)\n                         \n    if not data.ok:\n        print(\"Got Error ---> \",data.json().get('message_list', \n                                data.json().get('error_detail', data.json())))\n        exit(1)\n    else:\n        task_uuid = wait_for_completion(data)\n        vpc = {\"name\": params['name'], \n               \"uuid\":data.json()['metadata']['uuid'],\n               \"create_vpc_task_uuid\": task_uuid}\n        return vpc\n\ndef wait_for_completion(data):\n    if data.status_code in [200, 202]:\n        state = data.json()['status'].get('state')\n        while state == \"PENDING\":\n            _uuid = data.json()['status']['execution_context']['task_uuid']\n            url = _build_url(scheme=\"https\",\n                             resource_type=\"\/tasks\/%s\"%_uuid)\n            responce = requests.get(url, auth=HTTPBasicAuth(pc_username, pc_password), \n                                    verify=False)\n            if responce.json()['status'] in ['PENDING', 'RUNNING', 'QUEUED']:\n                state = 'PENDING'\n                sleep(5)                \n            elif responce.json()['status'] == 'FAILED':\n                print(\"Got Error ---> \",responce.json().get('message_list', \n                                        responce.json().get('error_detail', responce.json())))\n                state = 'FAILED'\n                exit(1)\n            else:\n                state = \"COMPLETE\"\n    else:\n        print(\"Got Error ---> \",data.json().get('message_list', \n                                data.json().get('error_detail', data.json())))\n        exit(1)\n    return data.json()['status']['execution_context']['task_uuid']\n    \ndef _get_vlan_uuid(**params):\n    vlan_name = params[\"external_subnet_name\"]\n    existing_subnet = @@{external_subnet_details}@@\n    for _subnet in existing_subnet:\n        if _subnet['name'] == vlan_name:\n            return _subnet['uuid']\n    _url = _build_url(scheme=\"https\",\n                    resource_type=\"\/subnets\/list\")\n    _data = requests.post(_url, json={\"kind\": \"subnet\"},\n                        auth=HTTPBasicAuth(pc_username, pc_password),\n                        verify=False)\n    _uuid = \"\"\n    if vlan_name in str(_data.json()):\n        for x in range(len(_data.json()['entities'])):\n            if str(_data.json()['entities'][x]['spec']['name']) == vlan_name:\n                _uuid = str(_data.json()['entities'][x]['metadata']['uuid'])\n                return _uuid\n    else:\n        print(\"Error ---> %s subnet not present on host\"%vlan_name)\n        exit(1)\n\ndef validate_params():\n    params = {}\n    print(\"##### creating VPC #####\")\n    vpc_details = []\n    params_dict = @@{vpc_items}@@\n    params['name'] = params_dict['name']\n    params['uuid'] = params_dict.get('uuid', \"None\")\n    if params_dict.get(\"dns_servers\", \"None\") != \"None\":\n        params[\"common_domain_name_server_ip_list\"] = [{}]\n        params[\"common_domain_name_server_ip_list\"][0]['ip'] = \\\n                                            params_dict.get('dns_servers', 'None')\n    params[\"external_subnet_list\"] = [{}]\n    if params_dict.get(\"externally_routable_ip\", \"None\") != \"None\":\n        params[\"externally_routable_prefix_list\"] = [{}]\n        params[\"externally_routable_prefix_list\"][0][\"ip\"] = \\\n                                            params_dict[\"externally_routable_ip\"]\n        params[\"externally_routable_prefix_list\"][0][\"prefix_length\"] = \\\n                                            params_dict[\"externally_routable_ip_prefix\"]\n                                            \n    if params_dict.get(\"external_subnet_name\", \"None\") != \"None\":\n        params[\"external_subnet_list\"][0][\"external_subnet_reference\"] = {}\n        params[\"external_subnet_list\"][0][\"external_subnet_reference\"][\"kind\"] = \"subnet\"\n        params[\"external_subnet_list\"][0][\"external_subnet_reference\"][\"name\"] = \\\n                                            params_dict[\"external_subnet_name\"]\n        params[\"external_subnet_list\"][0][\"external_subnet_reference\"][\"uuid\"] = \\\n                                            _get_vlan_uuid(**params_dict)\n                                            \n    if params_dict.get(\"external_subnet_uuid\", \"None\") != \"None\":\n        params[\"external_subnet_list\"][0][\"external_subnet_reference\"][\"uuid\"] = \\\n                                                    params_dict['external_subnet_uuid']\n    vpc_details.append(create_vpc(**params))\n    print(\"vpc_details={}\".format(vpc_details))\n\nvalidate_params()","eval_variables":["vpc_details"],"eval_scope":"local","type":"","script_type":"static"},"timeout_secs":"0","type":"SET_VARIABLE","variable_list":[]},{"retries":"0","description":"","inherit_target":false,"child_tasks_local_reference_list":[],"name":"Create Overlay Subnet","attrs":{"exit_status":[],"script":"#script\n\nimport requests\nfrom requests.auth import HTTPBasicAuth\n\nPC_IP = \"@@{PC_IP}@@\"\npc_username = \"@@{prism_central_username}@@\"\npc_password = \"@@{prism_central_passwd}@@\"\n\ndef _build_url(scheme, resource_type, host=PC_IP, **params):\n    _base_url = \"\/api\/nutanix\/v3\"\n    url = \"{proto}:\/\/{host}\".format(proto=scheme, host=host)\n    port = params.get('nutanix_port', '9440')\n    if port:\n        url = url + \":{0}\".format(port) + _base_url\n    if resource_type.startswith(\"\/\"):\n        url += resource_type\n    else:\n        url += \"\/{0}\".format(resource_type)\n    return url\n\ndef _get_vpc_details(vpc_name):\n    for vpc in @@{vpc_details}@@:\n        if vpc['name'] == vpc_name:\n            _vpc = {\"kind\": \"vpc\", \"uuid\": vpc['uuid']}\n            return _vpc\n\ndef _get_default_spec():\n    return (\n        {\n          \"api_version\": \"3.1.0\",\n          \"metadata\": {\"kind\": \"subnet\"},\n          \"spec\": {\n                  \"name\": \"\",\n                  \"resources\": {\n                      \"ip_config\": {},\n                      \"subnet_type\": None,\n                      },\n                  },\n              }\n          )\n\ndef _get_ipam_spec(**params):\n    ipam_spec = {}\n    if params['set_ipam'] == 'yes':\n        ipam_spec = _get_default_ipconfig_spec()\n        ipam_config = params[\"ipam\"]\n        ipam_spec[\"subnet_ip\"] = ipam_config[\"network_ip\"]\n        ipam_spec[\"prefix_length\"] = ipam_config[\"network_prefix\"]\n        ipam_spec[\"default_gateway_ip\"] = ipam_config[\"gateway_ip\"]\n        pools = []\n        for ip_pools in params['ip_pool']:\n            pools.append({\"range\": \"%s %s\"%(ip_pools['ip_pools_start_ip'], \n                                            ip_pools['ip_pools_end_ip'])})                                \n        ipam_spec[\"pool_list\"] = pools\n        if \"dhcp_options\" in ipam_config:\n            dhcp_spec = _get_default_dhcp_spec()\n            dhcp_config = ipam_config[\"dhcp_options\"]\n            if dhcp_config['domain_name_server_list'] != 'None': \n                dhcp_spec[\"domain_name_server_list\"] = dhcp_config[\"domain_name_server_list\"]\n            if dhcp_config[\"domain_search_list\"] != 'None':\n                dhcp_spec[\"domain_search_list\"] = dhcp_config[\"domain_search_list\"]\n            if dhcp_config[\"domain_name\"] != 'None':\n                dhcp_spec[\"domain_name\"] = dhcp_config[\"domain_name\"]\n            if dhcp_config[\"boot_file_name\"] != 'None':\n              dhcp_spec[\"boot_file_name\"] = dhcp_config[\"boot_file_name\"]\n            if dhcp_config[\"tftp_server_name\"] != 'None':\n                dhcp_spec[\"tftp_server_name\"] = dhcp_config[\"tftp_server_name\"]\n            ipam_spec[\"dhcp_options\"] = dhcp_spec\n    return ipam_spec\n\ndef _get_default_ipconfig_spec():\n    return (\n        {\n         \"subnet_ip\": None,\n         \"prefix_length\": None,\n         \"default_gateway_ip\": None,\n         \"pool_list\": [],\n        }\n      )\n\ndef _get_default_dhcp_spec():\n    return (\n      {\n        \"domain_name_server_list\": [],\n        \"domain_search_list\": [],\n        \"domain_name\": \"\",\n                \"boot_file_name\": \"\",\n                \"tftp_server_name\": \"\",\n       }\n    )\n\ndef wait_for_completion(data):\n    if data.status_code in [200, 202]:\n        state = data.json()['status'].get('state')\n        while state == \"PENDING\":\n            _uuid = data.json()['status']['execution_context']['task_uuid']\n            url = _build_url(scheme=\"https\",\n                            resource_type=\"\/tasks\/%s\"%_uuid)\n            responce = requests.get(url, auth=HTTPBasicAuth(pc_username, pc_password), \n                                    verify=False)\n            if responce.json()['status'] in ['PENDING', 'RUNNING', 'QUEUED']:\n                state = 'PENDING'\n                sleep(5)                \n            elif responce.json()['status'] == 'FAILED':\n                print(\"Got Error ---> \",responce.json().get('message_list', \n                                        responce.json().get('error_detail', responce.json())))\n                state = 'FAILED'\n                exit(1)\n            else:\n                state = \"COMPLETE\"\n    else:\n        print(\"Got Error ---> \",data.json().get('message_list', \n                                data.json().get('error_detail', data.json())))\n        exit(1)\n    return data.json()['status']['execution_context']['task_uuid']  \n                                     \ndef overlay_subnet():\n    params = {}\n    overlay_subnet_details = []\n    print(\"##### Creating Overlay Subnets #####\")\n    params_dict = @@{overlay_subnet_items}@@\n    params['vpc_name'] = params_dict.get('vpc_name', 'None')\n    params['ipam'] = {}\n    params['set_ipam'] = \"yes\"\n    params['ipam']['network_ip'] = params_dict.get('network_ip', 'None')\n    params['ipam']['network_prefix'] = params_dict.get('prefix', 'None')\n    params['ipam']['gateway_ip'] = params_dict.get('gateway_ip', 'None')\n    params['ip_pool'] = params_dict['ip_pool']\n    params['dhcp'] = params_dict.get('dhcp', 'None')\n    params['ipam']['dhcp_options'] = {}\n    params['ipam']['dhcp_options']['domain_name_server_list'] = params_dict.get('dns_servers', 'None')\n    params['ipam']['dhcp_options']['domain_search_list'] = params_dict.get('domain_search', 'None')\n    params['ipam']['dhcp_options']['domain_name'] = params_dict.get('domain_name', 'None')\n    params['ipam']['dhcp_options']['boot_file_name'] = params_dict.get('boot_file', \"None\")\n    params['ipam']['dhcp_options']['tftp_server_name'] = params_dict.get('tftp_server', \"None\")\n            \n    payload = _get_default_spec()\n    if params_dict.get('vpc_name', 'None') != 'None':\n        params['vpc_reference'] = _get_vpc_details(params['vpc_name'])\n        payload[\"spec\"][\"resources\"][\"vpc_reference\"] = params['vpc_reference']\n    payload[\"spec\"]['name'] = params_dict['subnet_name']\n    payload[\"spec\"][\"resources\"][\"subnet_type\"] = \"OVERLAY\"\n            \n    if params_dict.get('network_ip', 'None') != 'None':\n        params['ipam_spec'] = _get_ipam_spec(**params)\n        print(\"Overlay Subnet IP range - %s\"%params['ip_pool'])\n        payload[\"spec\"][\"resources\"][\"ip_config\"] = params['ipam_spec']\n\n\n    url = _build_url(scheme=\"https\",\n                    resource_type=\"\/subnets\")    \n    data = requests.post(url, json=payload,\n                         auth=HTTPBasicAuth(pc_username, pc_password),\n                         timeout=None, verify=False)\n    task_uuid = wait_for_completion(data)\n    details = {\"uuid\":data.json()['metadata']['uuid'],\n                               \"name\": params_dict['subnet_name'],\n                               \"create_subnet_task_uuid\": task_uuid}\n    overlay_subnet_details.append(details)\n    print(\"overlay_subnet_details={}\".format(overlay_subnet_details))\noverlay_subnet()","eval_variables":["overlay_subnet_details"],"eval_scope":"local","type":"","script_type":"static"},"timeout_secs":"0","type":"SET_VARIABLE","variable_list":[]},{"retries":"0","description":"","inherit_target":false,"child_tasks_local_reference_list":[],"name":"Create Project","attrs":{"exit_status":[],"script":"# script\n\nimport requests\nfrom requests.auth import HTTPBasicAuth\n\nROLE_ADMIN = \"Project Admin\"\nROLE_OPERATOR = \"Operator\"\nROLE_DEVELOPER = \"Developer\"\nROLE_CONSUMER = \"Consumer\"\nROOT_OU = 'tenants'\n\nPC_IP = \"@@{PC_IP}@@\"\npc_username = \"@@{prism_central_username}@@\"\npc_password = \"@@{prism_central_passwd}@@\"\n\ndef get_role_uuid(role_name):\n    api_url = 'https:\/\/{}:9440\/api\/nutanix\/v3\/roles\/list'.format(PC_IP)\n    payload = {\n      'filter': 'name=={}'.format(role_name),\n      'kind': 'role',\n      'offset': 0\n    }\n    r = requests.post(api_url, json=payload, \n                    auth=HTTPBasicAuth(pc_username, pc_password), \n                    timeout=None, verify=False)\n    result = json.loads(r.content)\n    if result.get('entities', 'None') != 'None':\n        return result['entities'][0]['metadata']['uuid']\n    else:\n        print(\"Error :- {}\".format(r.content))\n        exit(1)\n\ndef get_spec(role_uuid, user_uuid, user_name, idp_uuid, account_uuid, subnet_uuid, vpc_uuid, project_name):\n    return ({\n    \"spec\": {\n        \"access_control_policy_list\": [\n            {\n                \"acp\": {\n                    \"name\": \"ADMIN-ACP-@@{tenant_uuid}@@\",\n                    \"resources\": {\n                        \"role_reference\": {\n                            \"name\": \"Project Admin\",\n                            \"uuid\": role_uuid,\n                            \"kind\": \"role\"\n                        },\n                        \"user_group_reference_list\": [],\n                        \"user_reference_list\": [\n                            {\n                                \"name\": user_name,\n                                \"kind\": \"user\",\n                                \"uuid\": user_uuid\n                            }\n                        ],\n                        \"filter_list\": {\n                            \"context_list\": [\n                                {\n                                    \"scope_filter_expression_list\": [\n                                        {\n                                            \"operator\": \"IN\",\n                                            \"left_hand_side\": \"PROJECT\",\n                                            \"right_hand_side\": {\n                                                \"uuid_list\": [\n                                                    \"740ade18-94ad-459e-a607-c14f33020948\"\n                                                ]\n                                            }\n                                        }\n                                    ],\n                                    \"entity_filter_expression_list\": [\n                                        {\n                                            \"operator\": \"IN\",\n                                            \"left_hand_side\": {\n                                                \"entity_type\": \"ALL\"\n                                            },\n                                            \"right_hand_side\": {\n                                                \"collection\": \"ALL\"\n                                            }\n                                        }\n                                    ]\n                                },\n                                {\n                                    \"entity_filter_expression_list\": [\n                                        {\n                                            \"operator\": \"IN\",\n                                            \"left_hand_side\": {\n                                                \"entity_type\": \"image\"\n                                            },\n                                            \"right_hand_side\": {\n                                                \"collection\": \"ALL\"\n                                            }\n                                        },\n                                        {\n                                            \"operator\": \"IN\",\n                                            \"left_hand_side\": {\n                                                \"entity_type\": \"marketplace_item\"\n                                            },\n                                            \"right_hand_side\": {\n                                                \"collection\": \"SELF_OWNED\"\n                                            }\n                                        },\n                                        {\n                                            \"operator\": \"IN\",\n                                            \"right_hand_side\": {\n                                                \"collection\": \"ALL\"\n                                            },\n                                            \"left_hand_side\": {\n                                                \"entity_type\": \"directory_service\"\n                                            }\n                                        },\n                                        {\n                                            \"operator\": \"IN\",\n                                            \"right_hand_side\": {\n                                                \"collection\": \"ALL\"\n                                            },\n                                            \"left_hand_side\": {\n                                                \"entity_type\": \"role\"\n                                            }\n                                        },\n                                        {\n                                            \"operator\": \"IN\",\n                                            \"right_hand_side\": {\n                                                \"uuid_list\": [\n                                                    \"740ade18-94ad-459e-a607-c14f33020948\"\n                                                ]\n                                            },\n                                            \"left_hand_side\": {\n                                                \"entity_type\": \"project\"\n                                            }\n                                        },\n                                        {\n                                            \"operator\": \"IN\",\n                                            \"right_hand_side\": {\n                                                \"collection\": \"ALL\"\n                                            },\n                                            \"left_hand_side\": {\n                                                \"entity_type\": \"user\"\n                                            }\n                                        },\n                                        {\n                                            \"operator\": \"IN\",\n                                            \"right_hand_side\": {\n                                                \"collection\": \"ALL\"\n                                            },\n                                            \"left_hand_side\": {\n                                                \"entity_type\": \"user_group\"\n                                            }\n                                        },\n                                        {\n                                            \"operator\": \"IN\",\n                                            \"left_hand_side\": {\n                                                \"entity_type\": \"environment\"\n                                            },\n                                            \"right_hand_side\": {\n                                                \"collection\": \"SELF_OWNED\"\n                                            }\n                                        },\n                                        {\n                                            \"operator\": \"IN\",\n                                            \"right_hand_side\": {\n                                                \"collection\": \"ALL\"\n                                            },\n                                            \"left_hand_side\": {\n                                                \"entity_type\": \"app_icon\"\n                                            }\n                                        },\n                                        {\n                                            \"operator\": \"IN\",\n                                            \"right_hand_side\": {\n                                                \"collection\": \"ALL\"\n                                            },\n                                            \"left_hand_side\": {\n                                                \"entity_type\": \"category\"\n                                            }\n                                        },\n                                        {\n                                            \"operator\": \"IN\",\n                                            \"left_hand_side\": {\n                                                \"entity_type\": \"app_task\"\n                                            },\n                                            \"right_hand_side\": {\n                                                \"collection\": \"SELF_OWNED\"\n                                            }\n                                        },\n                                        {\n                                            \"operator\": \"IN\",\n                                            \"left_hand_side\": {\n                                                \"entity_type\": \"app_variable\"\n                                            },\n                                            \"right_hand_side\": {\n                                                \"collection\": \"SELF_OWNED\"\n                                            }\n                                        },\n                                        {\n                                            \"operator\": \"IN\",\n                                            \"right_hand_side\": {\n                                                \"collection\": \"ALL\"\n                                            },\n                                            \"left_hand_side\": {\n                                                \"entity_type\": \"identity_provider\"\n                                            }\n                                        },\n                                        {\n                                            \"operator\": \"IN\",\n                                            \"left_hand_side\": {\n                                                \"entity_type\": \"vm_recovery_point\"\n                                            },\n                                            \"right_hand_side\": {\n                                                \"collection\": \"ALL\"\n                                            }\n                                        },\n                                        {\n                                            \"operator\": \"IN\",\n                                            \"left_hand_side\": {\n                                                \"entity_type\": \"cluster\"\n                                            },\n                                            \"right_hand_side\": {\n                                                \"uuid_list\": [\n                                                    \"@@{cluster_uuid}@@\"\n                                                ]\n                                            }\n                                        }\n                                    ]\n                                },\n                                {\n                                    \"scope_filter_expression_list\": [\n                                        {\n                                            \"operator\": \"IN\",\n                                            \"left_hand_side\": \"PROJECT\",\n                                            \"right_hand_side\": {\n                                                \"uuid_list\": [\n                                                    \"740ade18-94ad-459e-a607-c14f33020948\"\n                                                ]\n                                            }\n                                        }\n                                    ],\n                                    \"entity_filter_expression_list\": [\n                                        {\n                                            \"operator\": \"IN\",\n                                            \"left_hand_side\": {\n                                                \"entity_type\": \"blueprint\"\n                                            },\n                                            \"right_hand_side\": {\n                                                \"collection\": \"ALL\"\n                                            }\n                                        },\n                                        {\n                                            \"operator\": \"IN\",\n                                            \"left_hand_side\": {\n                                                \"entity_type\": \"environment\"\n                                            },\n                                            \"right_hand_side\": {\n                                                \"collection\": \"ALL\"\n                                            }\n                                        },\n                                        {\n                                            \"operator\": \"IN\",\n                                            \"left_hand_side\": {\n                                                \"entity_type\": \"marketplace_item\"\n                                            },\n                                            \"right_hand_side\": {\n                                                \"collection\": \"ALL\"\n                                            }\n                                        }\n                                    ]\n                                }\n                            ]\n                        }\n                    },\n                    \"description\": \"untitledAcp-3ef331e0-fdbf-c71d-c1f9-46799dc450f2\"\n                },\n                \"metadata\": {\n                    \"kind\": \"access_control_policy\"\n                },\n                \"operation\": \"ADD\"\n            }\n        ],\n        \"project_detail\": {\n            \"name\": project_name,\n            \"resources\": {\n                \"external_network_list\": [],\n                \"account_reference_list\": [\n                    {\n                        \"kind\": \"account\",\n                        \"uuid\": account_uuid\n                    }\n                ],\n                \"user_reference_list\": [\n                    {\n                        \"name\": user_name,\n                        \"kind\": \"user\",\n                        \"uuid\": user_uuid\n                    }\n                ],\n                \"default_subnet_reference\": {\n                    \"kind\": \"subnet\",\n                    \"uuid\": subnet_uuid\n                },\n                \"vpc_reference_list\": [\n                    {\n                        \"kind\": \"vpc\",\n                        \"uuid\": vpc_uuid\n                    }\n                ],\n                \"tunnel_reference_list\": [],\n                \"external_user_group_reference_list\": [],\n                \"subnet_reference_list\": [\n                    {\n                        \"kind\": \"subnet\",\n                        \"uuid\": subnet_uuid\n                    }\n                ],\n                \"resource_domain\": {},\n                \"cluster_reference_list\": [\n                    {\n                        \"kind\": \"cluster\",\n                        \"uuid\": \"@@{cluster_uuid}@@\"\n                    }\n                ],\n                \"environment_reference_list\": []\n            },\n            \"description\": \"Tenant Onboarding Project\"\n        },\n        \"user_list\": [\n            {\n                \"metadata\": {\n                    \"kind\": \"user\",\n                    \"uuid\": user_uuid\n                },\n                \"user\": {\n                    \"resources\": {\n                        \"identity_provider_user\": {\n                            \"username\": user_name,\n                            \"identity_provider_reference\": {\n                                \"uuid\": idp_uuid,\n                                \"kind\": \"identity_provider\"\n                            }\n                        }\n                    }\n                },\n                \"operation\": \"ADD\"\n            }\n        ],\n        \"user_group_list\": []\n    },\n    \"api_version\": \"3.1\",\n    \"metadata\": {\n        \"kind\": \"project\"\n    }})\n\ndef _build_url(scheme, resource_type, host=PC_IP, **params):\n    _base_url = \"\/api\/nutanix\/v3\"\n    url = \"{proto}:\/\/{host}\".format(proto=scheme, host=host)\n    port = params.get('nutanix_port', '9440')\n    if port:\n        url = url + \":{0}\".format(port) + _base_url\n    if resource_type.startswith(\"\/\"):\n        url += resource_type\n    else:\n        url += \"\/{0}\".format(resource_type)\n    return url\n\ndef _get_default_spec():\n    return (\n        {\n          \"api_version\": \"3.1.0\",\n          \"metadata\": {\"kind\": \"project\"},\n          \"spec\": {\n              \"project_detail\" : {\n                  \"name\": \"\",\n                  \"resources\": {}\n                  }\n                }\n            }\n        )\n\ndef _get_group_spec():\n\treturn ({\n  \t\t\t\"api_version\": \"3.1.0\",\n  \t\t\t\"metadata\": {\n    \t\t\t\"kind\": \"user_group\"\n  \t\t\t\t},\n \t\t\t\"spec\": {\n    \t\t\t\"resources\": {\n      \t\t\t\t\"directory_service_user_group\": {\n        \t\t\t\t\"distinguished_name\": \"\"\n      \t\t\t\t\t}\n    \t\t\t\t}\n  \t\t\t\t}\n\t\t\t})\n            \ndef convert_domain_to_ad_path(group_name):\n    path = ''\n    g_name, domain = group_name.split(\"@\")\n    path = \"cn=%s,cn=users\"%g_name\n    for i in domain.split(\".\"):\n        path = path + ',DC={}'.format(i)\n    \n    return path\n    \ndef create_group(group):\n    payload = _get_group_spec()\n    group_name = convert_domain_to_ad_path(group)\n    if group != \"None\":\n        payload['spec']['resources']['directory_service_user_group']\\\n        \t\t\t['distinguished_name'] = group_name\n    url = _build_url(scheme=\"https\",resource_type=\"\/user_groups\")\n    data = requests.post(url, json=payload,\n                        auth=HTTPBasicAuth(\"admin\", \n                                           \"Nutanix.123\"),\n                        timeout=None, verify=False)    \n    wait_for_completion(data)\n    \n    if not data.ok:\n        if \"DUPLICATE\" in str(data.json()):\n            return \"ok\"\n        else:\n            print(\"Error while creating user_group ----> \",data.json())\n            return \"None\"\n    else:\n        return \"ok\"    \n            \ndef get_user_uuid(user, **params):\n    _payload = {\"entity_type\": \"abac_user_capability\",\n                \"group_member_attributes\": [\n               {\n                   \"attribute\": \"display_name\"\n               },\n               {\n                   \"attribute\": \"user_uuid\"\n               },\n               {\n                   \"attribute\": \"username\"\n               }\n           ],\n           \"query_name\": \"prism:BaseGroupModel\"\n         }\n    url = _build_url(scheme=\"https\",\n                    resource_type=\"\/groups\")\n    data = requests.post(url, json=_payload,\n                        auth=HTTPBasicAuth(pc_username, pc_password),\n                        timeout=None, verify=False)\n    if data.ok:\n        for user_data in data.json()[\"group_results\"][0][\"entity_results\"]:\n            if user_data[\"data\"][2][\"values\"][0][\"values\"][0] == user.strip():\n                return user_data[\"entity_id\"]\n    else:\n        print(\"Error while fetching user details :- \",data.json())\n        exit(1)\n                \n    url = _build_url(scheme=\"https\",\n                    resource_type=\"\/idempotence_identifiers\/salted\")\n    payload = {\"name_list\":[user]}\n    data = requests.post(url, json=payload,\n                        auth=HTTPBasicAuth(pc_username, pc_password),\n                        timeout=None, verify=False)                   \n    if data.ok:\n        _uuid = data.json()[\"name_uuid_list\"][0][user]\n        print(\"user_uuid----> %s\"%_uuid)\n        return _uuid\n    else:\n        print(\"Error while fetching user details :- \",data.json())\n        exit(1)\n\ndef build_project(**params):    \n    vpc_details = @@{vpc_details}@@\n    admin_role_uuid = get_role_uuid(ROLE_ADMIN)\n    operator_role_uuid = get_role_uuid(ROLE_OPERATOR)\n    developer_role_uuid = get_role_uuid(ROLE_DEVELOPER)\n    consumer_role_uuid = get_role_uuid(ROLE_CONSUMER)\n    print('ROLE_ADMIN_UUID={}'.format(admin_role_uuid))\n    print('ROLE_OPERATOR_UUID={}'.format(operator_role_uuid))\n    print('ROLE_DEVELOPER_UUID={}'.format(developer_role_uuid))\n    print('ROLE_CONSUMER_UUID={}'.format(consumer_role_uuid))\n        \n    overlay_subnets = @@{overlay_subnet_details}@@\n    subnet_uuid = \"\"\n    subnet_name = \"\"\n    for _uuid in overlay_subnets:\n        subnet_uuid = _uuid['uuid']\n        subnet_name = _uuid['name']\n    \n    account_uuid = \"\"\n    if params.get('accounts', 'None') != \"None\":\n        url = _build_url(scheme=\"https\",resource_type=\"\/accounts\/list\")\n        data = requests.post(url, json={\"kind\":\"account\", \"filter\":\"name==%s\"%params['accounts']},\n                        auth=HTTPBasicAuth(pc_username, pc_password),\n                        timeout=None, verify=False)       \n        if params['accounts'] in str(data.json()):\n            for new_data in data.json()['entities']:\n                if new_data['metadata']['name'] == params['accounts']: \n                    account_uuid = new_data['metadata']['uuid']\n                    print(\"account_details={}\".format({\"uuid\": account_uuid}))\n        else:\n            print(\"Error : %s account not present on %s\"%(params['accounts'],PC_IP))\n            exit(1)         \n                                   \n    user_details = []\n    all_users = []\n    for x in range(len(params['tenant_users'])):\n        all_users.append(params['tenant_users'][x].get('admin',\\\n                      params['tenant_users'][x].get('operator',\\\n                      params['tenant_users'][x].get('developer',\\\n                      params['tenant_users'][x].get('consumer')))))\n    for _user in all_users:\n        for user in _user:\n            user_uuid = get_user_uuid(user, **params)\n            if user_uuid != \"None\":\n                user_details.append({'name':user, 'uuid':user_uuid})\n    print(\"user_details={}\".format(user_details))\n    \n    idp_uuid = @@{idp_details}@@\n    print(\"group_details={}\".format([]))\n    vpc_uuid = @@{vpc_details}@@\n    payload = get_spec(role_uuid=admin_role_uuid, \n                       user_uuid=user_details[0][\"uuid\"], \n                       user_name=user_details[0][\"name\"], \n                       idp_uuid=idp_uuid[\"uuid\"], \n                       account_uuid=account_uuid, \n                       subnet_uuid=subnet_uuid,\n                       vpc_uuid=vpc_uuid[0][\"uuid\"],\n                       project_name=params['name'])\n                       \n    if params.get(\"quotas\", \"None\") != \"None\":\n        payload[\"spec\"][\"project_detail\"][\"resources\"][\"resource_domain\"] = {}  \n        resources = []\n        for resource in params['quotas']:\n            if resource.get(\"mem_gb\", 0) != 0:\n                mem_gb = resource[\"mem_gb\"] * 1024 * 1024 * 1024\n                resources.append({\"resource_type\":\"MEMORY\", \"limit\":mem_gb})\n            if resource.get(\"storage_gb\", 0) != 0:\n                storage_gb = resource['storage_gb'] * 1024 * 1024 * 1024\n                resources.append({\"resource_type\":\"STORAGE\", \"limit\":storage_gb})\n            if resource.get(\"vcpu\", 0) != 0:\n                resources.append({\"resource_type\":\"VCPUS\", \"limit\":resource['vcpu']})\n        payload[\"spec\"][\"project_detail\"][\"resources\"][\"resource_domain\"] = {\"resources\": resources}\n        \n    url = _build_url(scheme=\"https\",resource_type=\"\/projects_internal\")\n    data = requests.post(url, json=payload,\n                        auth=HTTPBasicAuth(pc_username, pc_password),\n                        timeout=None, verify=False)\n    if data.ok:\n        wait_for_completion(data)\n    else:\n        print(\"Failed with Error ---> \",data.json().get('message_list', \n                                data.json().get('error_detail', data.json())))\n        exit(1)\n    \n    if 'status' not in data.json():\n        print(\"Project %s not created successfully.\"%params['name'])\n        print(data.json())\n        exit(1)\n    task_uuid = data.json()['status']['execution_context']['task_uuid']\n    if 'metadata' in data.json():\n        print(\"project_details={}\".format({\"uuid\":data.json()['metadata']['uuid'],\n                                       \"name\": params['name'],\n                                       \"create_project_task_uuid\": task_uuid}))\n    else:\n        print(\"Project not created successfully, Check inputs and payload\")\n        print(data.json())\n        exit(1)\n  \ndef wait_for_completion(data):\n    if data.ok:\n        state = data.json()['status'].get('state')\n        while state == \"PENDING\":\n            _uuid = data.json()['status']['execution_context']['task_uuid']\n            url = _build_url(scheme=\"https\",\n                             resource_type=\"\/tasks\/%s\"%_uuid)\n            responce = requests.get(url, auth=HTTPBasicAuth(\"admin\",\"Nutanix.123\"), \n                                    verify=False)                      \n            if responce.json()['status'] in ['PENDING', 'RUNNING', 'QUEUED']:\n                state = 'PENDING'\n                sleep(5)                \n            elif responce.json()['status'] == 'FAILED':\n                print(\"Got Error ---> \",responce.json().get('message_list', \n                                        responce.json().get('error_detail', responce.json())))\n                state = 'FAILED'\n                exit(1)\n            else:\n                state = \"COMPLETE\"\n    else:\n        state = data.json().get('state')\n        if \"DUPLICATE_ENTITY\" not in str(data.json()):\n            print(\"Error ---> \",data.json().get('message_list', \n                                data.json().get('error_detail', data.json())))\n            exit(1)\n\ndef validate_params():\n    params = @@{project_items}@@\n    print(\"##### Creating a Project #####\")\n    build_project(**params)                                                     \n\nvalidate_params()","eval_variables":["project_details","account_details","user_details","group_details","ROLE_DEVELOPER_UUID","ROLE_ADMIN_UUID","ROLE_OPERATOR_UUID","ROLE_CONSUMER_UUID"],"eval_scope":"local","type":"","script_type":"static"},"timeout_secs":"0","type":"SET_VARIABLE","variable_list":[]},{"retries":"0","description":"","inherit_target":false,"child_tasks_local_reference_list":[],"name":"Create Tunnel for VPC","attrs":{"script":"#script\n\nimport requests\nfrom requests.auth import HTTPBasicAuth\n\nPC_IP = \"@@{PC_IP}@@\"\npc_user = \"@@{prism_central_username}@@\"\npc_password = \"@@{prism_central_passwd}@@\"\n\ndef _build_url(scheme, resource_type, host=PC_IP, **params):\n    _base_url = \"\/api\/nutanix\/v3\"\n    url = \"{proto}:\/\/{host}\".format(proto=scheme, host=host)\n    port = params.get('nutanix_port', '9440')\n    if port:\n        url = url + \":{0}\".format(port) + _base_url\n    if resource_type.startswith(\"\/\"):\n        url += resource_type\n    else:\n        url += \"\/{0}\".format(resource_type)\n    return url\n\ndef get_spec(**params):\n    url = _build_url(scheme=\"https\",\n                    resource_type=\"\/idempotence_identifiers\")\n    data = requests.post(url, json={\"count\": 1,\"valid_duration_in_minutes\": 527040},\n                        auth=HTTPBasicAuth(pc_user, pc_password),\n                        timeout=None, verify=False)                   \n    if data.ok:\n        _uuid = data.json()['uuid_list'][0]\n    else:\n        print(\"Error :- Failed to generate Idempotence UUID.\")\n        exit(1)\n    return (\n    {\"api_version\": \"3.1.0\",\n    \"metadata\": {\n        \"kind\": \"network_group_tunnel\"\n    },\n    \"spec\": {\n        \"resources\": {\n            \"platform_vpc_uuid_list\": [\n                params[\"vpc_uuid\"]\n            ],\n            \"tunnel_reference\": {\n                \"kind\": \"tunnel\",\n                \"uuid\": _uuid,\n                \"name\": params[\"tunnel_name\"]\n            },\n            \"account_reference\": {\n                \"kind\": \"account\",\n                \"uuid\": params[\"account_uuid\"]\n            },\n            \"tunnel_vm_spec\": {\n                \"vm_name\": params[\"tunnel_name\"]+\"_\"+params[\"vpc_name\"]+\"_TunnelVM\",\n                \"subnet_uuid\": params[\"overlay_subnet_uuid\"],\n                \"cluster_uuid\": params[\"cluster_uuid\"]\n            }\n        },\n        \"name\": params[\"tunnel_name\"]\n      }\n    })\n\ndef create_tunnel(**params):\n    payload = get_spec(**params)\n    url = _build_url(scheme=\"https\",\n                    resource_type=\"network_groups\/tunnels\")\n    data = requests.post(url, json=payload,\n                        auth=HTTPBasicAuth(pc_user,pc_password),\n                        timeout=None, verify=False)\n    wait_for_completion(data)\n    \ndef wait_for_completion(data):\n    if data.ok:\n        state = 'PENDING'\n        while state == \"PENDING\":\n            _uuid = data.json()[\"request_id\"]\n            url = _build_url(scheme=\"https\",\n                             resource_type=\"\/tasks\/%s\"%_uuid)\n            responce = requests.get(url, auth=HTTPBasicAuth(pc_user, pc_password),\n                                    verify=False)                      \n            if responce.json()['status'] in ['PENDING', 'RUNNING', 'QUEUED']:\n                state = 'PENDING'\n                sleep(5)                \n            elif responce.json()['status'] == 'FAILED':\n                print(\"Error occured ---> \",responce.json().get('message_list', \n                                            responce.json().get('error_detail', \n                                                                responce.json())))\n                state = 'FAILED'\n                exit(1)\n            else:\n                state = \"SUCCEEDED\"\n    else:\n        print(\"Error occured ---> \",data.json().get('message_list', \n                                data.json().get('error_detail', data.json())))\n        exit(1)\n\nvpc = @@{vpc_details}@@\naccount = @@{account_details}@@\noverlay_subnet = @@{overlay_subnet_details}@@\nparams = {\"vpc_name\" : vpc[0][\"name\"],\n          \"vpc_uuid\" : vpc[0][\"uuid\"],\n          \"account_name\" : \"@@{account_name}@@\",\n          \"account_uuid\" : account[\"uuid\"],\n          \"overlay_subnet_uuid\" : overlay_subnet[0][\"uuid\"],\n          \"cluster_uuid\" : \"@@{cluster_uuid}@@\",\n          \"tunnel_name\" : \"@@{tenant_name}@@_VPC_Tunnel\"\n        }\ncreate_tunnel(**params)","type":"","command_line_args":"","exit_status":[],"script_type":"static"},"timeout_secs":"0","type":"EXEC","variable_list":[]},{"retries":"0","description":"","inherit_target":false,"child_tasks_local_reference_list":[],"name":"Set Quota","attrs":{"script":"# script\nimport requests\nfrom requests.auth import HTTPBasicAuth\n\nPC_IP = \"@@{PC_IP}@@\"\npc_username = \"@@{prism_central_username}@@\"\npc_password = \"@@{prism_central_passwd}@@\"\n\ndef _build_url(scheme, resource_type, host=PC_IP, **params):\n    _base_url = \"\/api\/nutanix\/v3\"\n    url = \"{proto}:\/\/{host}\".format(proto=scheme, host=host)\n    port = params.get('nutanix_port', '9440')\n    if port:\n        url = url + \":{0}\".format(port) + _base_url\n    if resource_type.startswith(\"\/\"):\n        url += resource_type\n    else:\n        url += \"\/{0}\".format(resource_type)\n    return url\n\ndef cluster_details(cluster=None):\n    cluster_name = \"@@{cluster_name}@@\"\n    if cluster != None:\n        cluster_name = cluster\n    payload = {\"kind\": \"cluster\"}\n    url = _build_url(scheme=\"https\",\n                    resource_type=\"\/clusters\/list\")\n    data = requests.post(url, json=payload,\n                         auth=HTTPBasicAuth(pc_username, pc_password), \n                         verify=False)\n    if data.ok:\n        for _cluster in data.json()['entities']:\n            if _cluster['status']['name'] == cluster_name:\n                return(str(_cluster['metadata']['uuid']))\n        print(\"Input Error :- Given cluster %s not present on %s\"%(cluster_name, PC_IP))\n        exit(1)\n    else:\n        print(\"Error while fetching %s cluster info\"%cluster_name)\n        print(data.json().get('message_list',data.json().get('error_detail', data.json())))\n        exit(1)\n        \ndef add_quotas(account,**params):\n    if params.get(\"quotas\", \"None\") != \"None\":\n        memory = 0\n        disk = 0\n        vcpus = 0\n        for resource in params['quotas']:\n            if resource.get(\"mem_gb\", 0) != 0:\n                mem_gb = resource[\"mem_gb\"] * 1024 * 1024 * 1024\n                memory = mem_gb\n            if resource.get(\"storage_gb\", 0) != 0:\n                storage_gb = resource['storage_gb'] * 1024 * 1024 * 1024\n                disk = storage_gb\n            if resource.get(\"vcpu\", 0) != 0:\n                vcpus = resource['vcpu']\n                \n        cluster_uuid = \"@@{cluster_uuid}@@\"\n        project_details = @@{project_details}@@\n        account_details = @@{account_details}@@\n        entities = {}\n        entities[\"account\"]=account_details['uuid']\n        entities[\"cluster\"]=cluster_uuid\n        entities[\"project\"]=project_details['uuid']\n\n        if not account:\n            entities = {\"project\": project_details['uuid']}\n            \n        url = _build_url(scheme=\"https\",\n                        resource_type=\"\/idempotence_identifiers\")\n        data = requests.post(url, json={\"count\": 1,\"valid_duration_in_minutes\": 527040},\n                            auth=HTTPBasicAuth(pc_username, pc_password),\n                            timeout=None, verify=False)\n        _uuid = data.json()['uuid_list'][0]\n        payload = ({\n            \"metadata\": {\n            \"kind\": \"quota\",\n            \"project_reference\": {\n                    \"kind\": \"project\",\n                    \"name\": project_details['name'],\n                    \"uuid\": project_details['uuid']\n                },\n            \"uuid\": _uuid\n            },\n            \"spec\": {\n                \"resources\": {\n                    \"data\": {\n                        \"disk\": disk,\n                        \"vcpu\": vcpus,\n                        \"memory\": memory\n                    },\n                    \"entities\": entities,\n                    \"metadata\": {},\n                    \"uuid\": _uuid\n                }\n            }})\n    \n        url = \"https:\/\/{}:9440\/api\/calm\/v3.0\/quotas\".format(PC_IP)\n        data = requests.post(url, json=payload,\n                        auth=HTTPBasicAuth(pc_username, \n                                           pc_password),\n                        timeout=None, verify=False)\n        wait_for_completion(data) \n    else:\n        print(\"Quota not set for project %s\"%project_details['name'])\n\ndef wait_for_completion(data):\n    if data.status_code in [200, 202]:\n        state = data.json()['status'].get('state')\n        while state == \"PENDING\":\n            _uuid = data.json()['status']['execution_context']['task_uuid']\n            url = _build_url(scheme=\"https\",\n                             resource_type=\"\/tasks\/%s\"%_uuid)\n            responce = requests.get(url, auth=HTTPBasicAuth(pc_username,pc_username), \n                                    verify=False)                      \n            if responce.json()['status'] in ['PENDING', 'RUNNING', 'QUEUED']:\n                state = 'PENDING'\n                sleep(5)                \n            elif responce.json()['status'] == 'FAILED':\n                print(\"Got Error ---> \",responce.json().get('message_list', \n                                        responce.json().get('error_detail', responce.json())))\n                state = 'FAILED'\n                exit(1)\n            else:\n                state = \"COMPLETE\"\n    else:\n        print(\"Got Error ---> \",data.json().get('message_list', \n                                data.json().get('error_detail', data.json())))\n        exit(1)\n\nif (@@{project_vcpu}@@ != 0) or (@@{project_memory}@@ != 0) or (@@{project_disk_size}@@ != 0):\n    params = @@{project_items}@@\n    add_quotas(account=False,**params)\n    params = @@{account_items}@@\n    add_quotas(account=True,**params)\nelse:\n    print(\"Info : Not setting Projects Quota, All Quota values are zero.\")","type":"","command_line_args":"","exit_status":[],"script_type":"static"},"timeout_secs":"0","type":"EXEC","variable_list":[]},{"retries":"0","description":"","inherit_target":false,"child_tasks_local_reference_list":[],"name":"Create Environment","attrs":{"exit_status":[],"script":"# script\nimport requests\nfrom requests.auth import HTTPBasicAuth\n\nPC_IP = \"@@{PC_IP}@@\"\npc_username = \"@@{prism_central_username}@@\"\npc_password = \"@@{prism_central_passwd}@@\"\n\ndef _build_url(scheme, resource_type, host=PC_IP, **params):\n    _base_url = \"\/api\/nutanix\/v3\"\n    url = \"{proto}:\/\/{host}\".format(proto=scheme, host=host)\n    port = params.get('nutanix_port', '9440')\n    if port:\n        url = url + \":{0}\".format(port) + _base_url\n    if resource_type.startswith(\"\/\"):\n        url += resource_type\n    else:\n        url += \"\/{0}\".format(resource_type)\n    return url\n    \ndef _get_spec():\n    tenantuuid = \"@@{tenant_uuid}@@\"\n    account = @@{account_details}@@\n    project = @@{project_details}@@\n    vpc_details = @@{vpc_details}@@\n    project_subnet = @@{overlay_subnet_details}@@\n    env_memory = @@{project_memory}@@ * 1024\n    subnet_references = []\n    nic_list = []\n    nics = {}\n    nics['subnet_reference'] = {'uuid': project_subnet[0][\"uuid\"]}\n    subnet_references.append({'uuid': project_subnet[0][\"uuid\"]})\n    nic_list.append(nics)\n    \n    url = _build_url(scheme=\"https\",\n                    resource_type=\"\/idempotence_identifiers\")\n    data = requests.post(url, json={\"count\": 2,\"valid_duration_in_minutes\": 527040},\n                        auth=HTTPBasicAuth(pc_username, pc_password),\n                        timeout=None, verify=False)\n    creds_uuid = \"\"\n    substrate_uuid = \"\"\n    if data.ok:\n        creds_uuid = data.json()['uuid_list'][0]\n        substrate_uuid = data.json()['uuid_list'][1]\n\n    _creds_type = \"@@{credential_type}@@\"\n    credential_definition_list = [\n                \t\t{\n                    \t\t\"name\": \"@@{tenant_name}@@_cred\",\n                    \t\t\"type\": _creds_type,\n                    \t\t\"username\": \"@@{credential_username}@@\",\n                    \t\t\"secret\": {\n                        \t\t\"attrs\": {\n                            \t\t\"is_secret_modified\": True,\n                                  \t\"secret_reference\" : {}\n                        \t\t},\n                        \t\t\"value\": \"\"\"@@{password_or_key}@@\"\"\"\n                    \t\t},\n                    \t\t\"uuid\": creds_uuid\n                \t\t}]\n    \n    if _creds_type == \"KEY\":\n        _pass = {\"passphrase\": {\n                    \"attrs\": {\n                        \"is_secret_modified\": True,\n                    },\n                    \"value\": \"@@{prism_central_passwd}@@\"\n                    }\n                }\n        credential_definition_list[0].update(_pass)\n    print(credential_definition_list)\n    gpu_list = []\n\n    disk_list = []\n    boot_type = \"LEGACY\"\n    boot_adapter = \"SCSI\"\n    image_uuid = \"\"\n    boot_index = 0\n    boot_adapter = \"SCSI\"\n    url = _build_url(scheme=\"https\",\n        resource_type=\"\/images\/list\")\n    data = requests.post(url, json={\"kind\":\"image\", \"filter\":\"name==%s\"%\"@@{image_name}@@\"},\n                            auth=HTTPBasicAuth(\"admin\", \"Nutanix.123\"),\n                            timeout=None, verify=False)\n    if data.ok:\n        image_uuid = data.json()['entities'][0]['metadata']['uuid']\n    else:\n        print(\"Error -- %s Image not present on %s\"%(\"@@{image_name}@@\", PC_IP))\n    disk_list.append({\"data_source_reference\": {\n                        \"kind\": \"image\",\n                        \"name\": \"@@{image_name}@@\",\n                        \"uuid\": image_uuid\n                        },\n                        \"device_properties\": {\n                        \"device_type\": \"DISK\",\n                        \"disk_address\": {\n                            \"device_index\": 0,\n                            \"adapter_type\": \"SCSI\"\n                        }},\n                        \"disk_size_mib\": 10,\n                        }\n                    )\n\n    serial_port = []\n    serial_port.append({\"index\": 0, \"is_connected\": True})\n        \n    return ({\n    \t\t\"api_version\": \"3.0\",\n    \t\t\"metadata\": {\n        \t\t\"kind\": \"environment\",\n        \t\t\"project_reference\": {\n            \t\t\"kind\": \"project\",\n            \t\t\"name\": project['name'],\n            \t\t\"uuid\": project['uuid']\n        \t\t}\n    \t\t},\n    \t\t\"spec\": {\n        \t\t\"name\": project['name']+\"_Environment\",\n        \t\t\"description\": tenantuuid+project['name'],\n        \t\t\"resources\": {\n            \t\t\"substrate_definition_list\": [\n                \t\t{\n                    \t\t\"variable_list\": [],\n                    \t\t\"type\": \"AHV_VM\",\n                    \t\t\"os_type\": \"@@{environment_os}@@\",\n                    \t\t\"action_list\": [],\n                    \t\t\"create_spec\": {\n                        \t\t\"name\": project['name']+\"_VM\",\n                                \"categories\": {},\n                                \"cluster_reference\": {\n                                    \"kind\": \"cluster\",\n                                    \"type\": \"\",\n                                    \"name\": \"@@{cluster_name}@@\",\n                                    \"uuid\": \"@@{cluster_uuid}@@\"\n                                },\n                        \t\t\"resources\": {\n                            \t\t\"disk_list\": disk_list,\n                                    \"gpu_list\": gpu_list,\n                                    \"serial_port_list\": serial_port,\n                            \t\t\"nic_list\": nic_list,\n                                    \"power_state\": \"ON\",\n                            \t\t\"boot_config\": {\n                                \t\t\"boot_device\": {\n                                    \t\t\"disk_address\": {\n                                        \t\t\"device_index\": boot_index,\n                                        \t\t\"adapter_type\": boot_adapter\n                                    \t\t}\n                                \t\t},\n                                \t\t\"boot_type\": boot_type\n                            \t\t},\n                            \t\t\"num_sockets\": 2,\n                            \t\t\"num_vcpus_per_socket\": @@{project_vcpu}@@,\n                            \t\t\"memory_size_mib\": env_memory,\n                            \t\t\"account_uuid\": account['uuid'],\n                                    \n                        \t\t},\n                        \t\t\"categories\": {\"TenantName\":\"@@{tenant_name}@@\"}\n                    \t\t},\n                    \t\t\"readiness_probe\": {\n                        \t\t\"disable_readiness_probe\": False,\n                        \t\t\"connection_type\": \"SSH\",\n                        \t\t\"connection_port\": 22,\n                                \"connection_protocol\": \"HTTP\",\n                                \"delay_secs\": \"5\",\n                        \t\t\"login_credential_local_reference\": {\n                            \t\t\"kind\": \"app_credential\",\n                            \t\t\"uuid\": creds_uuid\n                        \t\t},\n                                \"address\": \"@@{project_subnet_address}@@\"\n                    \t\t},\n                    \t\t\"name\": \"Untitled\",\n                            \"uuid\": substrate_uuid\n                \t\t}\n            \t\t],\n            \t\t\"credential_definition_list\": credential_definition_list,\n            \t\t\"infra_inclusion_list\": [\n                \t\t{\n                    \t\t\"account_reference\": {\n                        \t\t\"uuid\": account['uuid'],\n                        \t\t\"kind\": \"account\"\n                    \t\t},\n                    \t\t\"type\": \"nutanix_pc\",\n                    \t\t\"subnet_references\": subnet_references,\n                    \t\t\"default_subnet_reference\": subnet_references[0],\n                            \"vpc_references\": [{\"uuid\":vpc_details[0][\"uuid\"]}],\n                            \"cluster_references\": [{\"uuid\":\"@@{cluster_uuid}@@\"}]\n                \t\t}\n            \t\t]\n        \t\t}\n    \t\t}})\n\ndef create_env():\n    payload = _get_spec()\n    guest_customization = {}\n    if \"@@{environment_os}@@\" == \"Windows\":\n        guest_customization = {\"sysprep\":{\"install_type\": 'FRESH',\n                                              \"unattend_xml\": \"\"\"@@{guest_customization_script}@@\"\"\"}}\n    else:\n        guest_customization = {\"cloud_init\":{\"user_data\": \"\"\"@@{guest_customization_script}@@\"\"\"}}\n    payload['spec']['resources']['substrate_definition_list'][0]['create_spec']\\\n             ['resources']['guest_customization'] = guest_customization\n        \n    url = _build_url(scheme=\"https\",\n                    resource_type=\"\/environments\")\n    data = requests.post(url, json=payload,\n                        auth=HTTPBasicAuth(pc_username, pc_password),\n                        timeout=None, verify=False)\n    if not data.ok:\n        print(\"Error while creating environment ---> \",data.json().get('message_list', \n                                data.json().get('error_detail', data.json())))\n        exit(1)\n    return {\"uuid\": data.json()['metadata']['uuid'],\n           \t\t\t\"name\":payload['spec']['name'],\n                    \"default\": True}\nenvironments = []\nif \"@@{create_environment}@@\" == \"yes\":\n    environments.append(create_env())\nprint(\"environment_details={}\".format(environments))","eval_variables":["environment_details"],"eval_scope":"local","type":"","script_type":"static"},"timeout_secs":"0","type":"SET_VARIABLE","variable_list":[]},{"retries":"0","description":"","inherit_target":false,"child_tasks_local_reference_list":[],"name":"Update Project","attrs":{"script":"# script\nimport requests\nfrom requests.auth import HTTPBasicAuth\n\nPC_IP = \"@@{PC_IP}@@\"\npc_username = \"@@{prism_central_username}@@\"\npc_password = \"@@{prism_central_passwd}@@\"\n\ndef _build_url(scheme, resource_type, host=PC_IP, **params):\n    _base_url = \"\/api\/nutanix\/v3\"\n    url = \"{proto}:\/\/{host}\".format(proto=scheme, host=host)\n    port = params.get('nutanix_port', '9440')\n    if port:\n        url = url + \":{0}\".format(port) + _base_url\n    if resource_type.startswith(\"\/\"):\n        url += resource_type\n    else:\n        url += \"\/{0}\".format(resource_type)\n    return url\n    \ndef _get_spec(project):\n    url = _build_url(scheme=\"https\",\n                    resource_type=\"\/projects_internal\/{}\".format(project))\n    data = requests.get(url,\n                        auth=HTTPBasicAuth(pc_username, pc_password),\n                        timeout=None, verify=False)\n    return data.json()\n  \ndef user_list(user_name, user_uuid, idp_uuid):\n    return([\n              {\n                \"metadata\": {\n                  \"kind\": \"user\",\n                  \"uuid\": user_uuid\n                },\n                \"user\": {\n                  \"resources\": {\n                    \"identity_provider_user\": {\n                      \"username\": user_name,\n                      \"identity_provider_reference\": {\n                        \"uuid\": idp_uuid,\n                        \"kind\": \"identity_provider\"\n                      }\n                    }\n                  }\n                },\n                \"operation\": \"ADD\"\n              }\n            ])\ndef get_user_uuid(user, **params):\n    _payload = {\"entity_type\": \"abac_user_capability\",\n                \"group_member_attributes\": [\n               {\n                   \"attribute\": \"display_name\"\n               },\n               {\n                   \"attribute\": \"user_uuid\"\n               },\n               {\n                   \"attribute\": \"username\"\n               }\n           ],\n           \"query_name\": \"prism:BaseGroupModel\"\n         }\n    url = _build_url(scheme=\"https\",\n                    resource_type=\"\/groups\")\n    data = requests.post(url, json=_payload,\n                        auth=HTTPBasicAuth(pc_username, pc_password),\n                        timeout=None, verify=False)\n    if data.ok:\n        for user_data in data.json()[\"group_results\"][0][\"entity_results\"]:\n            if user_data[\"data\"][2][\"values\"][0][\"values\"][0] == user.strip():\n                return user_data[\"entity_id\"]\n    else:\n        print(\"Error while fetching user details :- \",data.json())\n        exit(1)\n                \n    url = _build_url(scheme=\"https\",\n                    resource_type=\"\/idempotence_identifiers\/salted\")\n    payload = {\"name_list\":[user]}\n    data = requests.post(url, json=payload,\n                        auth=HTTPBasicAuth(pc_username, pc_password),\n                        timeout=None, verify=False)                   \n    if data.ok:\n        _uuid = data.json()[\"name_uuid_list\"][0][user]\n        print(\"user_uuid----> %s\"%_uuid)\n        return _uuid\n    else:\n        print(\"Error while fetching user details :- \",data.json())\n        exit(1)\n        \ndef update_project(**params):\n    project = @@{project_details}@@\n    project_items = @@{project_items}@@\n    payload = _get_spec(project['uuid'])\n    for x in ['categories', 'categories_mapping', 'creation_time', 'last_update_time', 'owner_reference']:\n        del payload['metadata'][x]\n    del payload['status']\n    payload['spec']['access_control_policy_list'][0]['operation'] = \"UPDATE\"\n    payload['spec']['access_control_policy_list'][0]['acp']\\\n        ['resources']['filter_list']['context_list'][0]\\\n        ['scope_filter_expression_list'][0]['right_hand_side']['uuid_list'] = [project['uuid']]\n    \n    payload['spec']['access_control_policy_list'][0]['acp']['resources']\\\n        ['filter_list']['context_list'][1]['entity_filter_expression_list']\\\n        [4]['right_hand_side']['uuid_list'] = [project['uuid']]\n    \n    \n    payload['spec']['access_control_policy_list'][0]['acp']['resources']\\\n        ['filter_list']['context_list'][2]['scope_filter_expression_list']\\\n        [0]['right_hand_side']['uuid_list'] = [project['uuid']]\n    \n    env_uuid = @@{environment_details}@@\n    payload['spec']['project_detail']['resources']['environment_reference_list'] = []\n    if \"@@{create_environment}@@\" == \"yes\":\n        default_env_uuid = env_uuid[0]['uuid']\n        for env in env_uuid:\n            if env.get('default', False) == True:\n                default_env_uuid = env['uuid']\n            payload['spec']['project_detail']['resources']\\\n                ['environment_reference_list'].append({\"kind\":\"environment\",\n                                                   \"uuid\":env['uuid']})\n        payload['spec']['project_detail']['resources']\\\n            [\"default_environment_reference\"] = {\"kind\":\"environment\",\n                                      \"uuid\":default_env_uuid}\n        \n    url = _build_url(scheme=\"https\",\n                    resource_type=\"\/projects_internal\/{}\".format(project['uuid']))\n    data = requests.put(url, json=payload,\n                        auth=HTTPBasicAuth(pc_username, pc_password),\n                        timeout=None, verify=False)\n    if data.ok:\n        task = wait_for_completion(data)       \n        print(\"Project %s updated successfully\"%project['name'])\n    else:\n        print(\"Error while updating project : %s\"%data.json())\n        exit(1)\n    \ndef wait_for_completion(data):\n    if data.ok:\n        state = data.json()['status'].get('state')\n        while state == \"PENDING\":\n            _uuid = data.json()['status']['execution_context']['task_uuid']\n            url = _build_url(scheme=\"https\",\n                             resource_type=\"\/tasks\/%s\"%_uuid)\n            responce = requests.get(url, auth=HTTPBasicAuth(\n                                    pc_username, pc_password),\n                                    verify=False)\n            if responce.json()['status'] in ['PENDING', 'RUNNING', 'QUEUED']:\n                state = 'PENDING'\n                sleep(5)                \n            elif responce.json()['status'] == 'FAILED':\n                print(\"Error in project update ---> \",responce.json().get('message_list', \n                                        responce.json().get('error_detail', responce.json())))\n                state = 'FAILED'\n                exit(1)\n            else:\n                state = \"COMPLETE\"\n    else:\n        state = data.json().get('state')\n        print(\"Error in project update ---> \",data.json().get('message_list', \n                                data.json().get('error_detail', data.json())))\n        exit(1)\n\ndef generate_filter_list_admin(project_uuid, collection):\n    acl = []\n    acl.append({\"entity_filter_expression_list\":[\n            {\n                \"operator\": \"IN\",\n                \"left_hand_side\": {\"entity_type\": \"image\"},\n                \"right_hand_side\": {\"collection\": \"ALL\"},\n            },\n            {\n                \"operator\": \"IN\",\n                \"left_hand_side\": {\"entity_type\": \"marketplace_item\"},\n                \"right_hand_side\": {\"collection\": \"SELF_OWNED\"},\n            },\n            {\n                \"operator\": \"IN\",\n                \"right_hand_side\": {\"collection\": \"ALL\"},\n                \"left_hand_side\": {\"entity_type\": \"directory_service\"},\n            },\n            {\n                \"operator\": \"IN\",\n                \"right_hand_side\": {\"collection\": \"ALL\"},\n                \"left_hand_side\": {\"entity_type\": \"role\"},\n            },\n            {\n                \"operator\": \"IN\",\n                \"right_hand_side\": {\"uuid_list\": [project_uuid]},\n                \"left_hand_side\": {\"entity_type\": \"project\"},\n            },\n            {\n                \"operator\": \"IN\",\n                \"right_hand_side\": {\"collection\": \"ALL\"},\n                \"left_hand_side\": {\"entity_type\": \"user\"},\n            },\n            {\n                \"operator\": \"IN\",\n                \"right_hand_side\": {\"collection\": \"ALL\"},\n                \"left_hand_side\": {\"entity_type\": \"user_group\"},\n            },\n            {\n                \"operator\": \"IN\",\n                \"right_hand_side\": {\"collection\": \"SELF_OWNED\"},\n                \"left_hand_side\": {\"entity_type\": \"environment\"},\n            },\n            {\n                \"operator\": \"IN\",\n                \"right_hand_side\": {\"collection\": \"ALL\"},\n                \"left_hand_side\": {\"entity_type\": \"app_icon\"},\n            },\n            {\n                \"operator\": \"IN\",\n                \"right_hand_side\": {\"collection\": \"ALL\"},\n                \"left_hand_side\": {\"entity_type\": \"category\"},\n            },\n            {\n                \"operator\": \"IN\",\n                \"left_hand_side\": {\"entity_type\": \"app_task\"},\n                \"right_hand_side\": {\"collection\": \"SELF_OWNED\"},\n            },\n            {\n                \"operator\": \"IN\",\n                \"left_hand_side\": {\"entity_type\": \"app_variable\"},\n                \"right_hand_side\": {\"collection\": \"SELF_OWNED\"},\n            },\n        ]})\n\n    acl.append({\n        \"scope_filter_expression_list\": [\n            {\n                \"operator\": \"IN\",\n                \"left_hand_side\": \"PROJECT\",\n                \"right_hand_side\": {\"uuid_list\": []},\n            }\n        ],\n        \"entity_filter_expression_list\": [\n            {\n                \"operator\": \"IN\",\n                \"left_hand_side\": {\"entity_type\": \"ALL\"},\n                \"right_hand_side\": {\"collection\": collection},\n            }\n        ],\n    })\n    return acl\n\ndef generate_filter_list_operator(project_uuid, collection):\n    acl = []\n    acl.append({\"entity_filter_expression_list\":[\n        {\n            \"operator\": \"IN\",\n            \"right_hand_side\": {\"collection\": \"ALL\"},\n            \"left_hand_side\": {\"entity_type\": \"app_icon\"},\n        },\n        {\n            \"operator\": \"IN\",\n            \"right_hand_side\": {\"collection\": \"ALL\"},\n            \"left_hand_side\": {\"entity_type\": \"category\"},\n        },\n    ]})\n\n    acl.append({\n        \"scope_filter_expression_list\": [\n            {\n                \"operator\": \"IN\",\n                \"left_hand_side\": \"PROJECT\",\n                \"right_hand_side\": {\"uuid_list\": [project_uuid]},\n            }\n        ],\n        \"entity_filter_expression_list\": [\n            {\n                \"operator\": \"IN\",\n                \"left_hand_side\": {\"entity_type\": \"ALL\"},\n                \"right_hand_side\": {\"collection\": collection},\n            }\n        ],\n    })\n    return acl   \n\ndef generate_filter_list_developer(project_uuid, collection):\n    acl = []\n    acl.append({\"entity_filter_expression_list\":[\n        {\n            \"operator\": \"IN\",\n            \"left_hand_side\": {\"entity_type\": \"image\"},\n            \"right_hand_side\": {\"collection\": \"ALL\"},\n        },\n        {\n            \"operator\": \"IN\",\n            \"left_hand_side\": {\"entity_type\": \"marketplace_item\"},\n            \"right_hand_side\": {\"collection\": \"SELF_OWNED\"},\n        },\n        {\n            \"operator\": \"IN\",\n            \"right_hand_side\": {\"collection\": \"ALL\"},\n            \"left_hand_side\": {\"entity_type\": \"app_icon\"},\n        },\n        {\n            \"operator\": \"IN\",\n            \"right_hand_side\": {\"collection\": \"ALL\"},\n            \"left_hand_side\": {\"entity_type\": \"category\"},\n        },\n        {\n            \"operator\": \"IN\",\n            \"left_hand_side\": {\"entity_type\": \"app_task\"},\n            \"right_hand_side\": {\"collection\": \"SELF_OWNED\"},\n        },\n        {\n            \"operator\": \"IN\",\n            \"left_hand_side\": {\"entity_type\": \"app_variable\"},\n            \"right_hand_side\": {\"collection\": \"SELF_OWNED\"},\n        },\n    ]})\n\n    acl.append({\n        \"scope_filter_expression_list\": [\n            {\n                \"operator\": \"IN\",\n                \"left_hand_side\": \"PROJECT\",\n                \"right_hand_side\": {\"uuid_list\": [project_uuid]},\n            }\n        ],\n        \"entity_filter_expression_list\": [\n            {\n                \"operator\": \"IN\",\n                \"left_hand_side\": {\"entity_type\": \"ALL\"},\n                \"right_hand_side\": {\"collection\": collection},\n            }\n        ],\n    })\n    return acl\n\ndef generate_filter_list_consumer(project_uuid, collection):\n    acl = []\n    acl.append({\"entity_filter_expression_list\":[\n            {\n                \"operator\": \"IN\",\n                \"left_hand_side\": {\"entity_type\": \"image\"},\n                \"right_hand_side\": {\"collection\": \"ALL\"},\n            },\n            {\n                \"operator\": \"IN\",\n                \"left_hand_side\": {\"entity_type\": \"marketplace_item\"},\n                \"right_hand_side\": {\"collection\": \"SELF_OWNED\"},\n            },\n            {\n                \"operator\": \"IN\",\n                \"right_hand_side\": {\"collection\": \"ALL\"},\n                \"left_hand_side\": {\"entity_type\": \"app_icon\"},\n            },\n            {\n                \"operator\": \"IN\",\n                \"right_hand_side\": {\"collection\": \"ALL\"},\n                \"left_hand_side\": {\"entity_type\": \"category\"},\n            },\n            {\n                \"operator\": \"IN\",\n                \"left_hand_side\": {\"entity_type\": \"app_task\"},\n                \"right_hand_side\": {\"collection\": \"SELF_OWNED\"},\n            },\n            {\n                \"operator\": \"IN\",\n                \"left_hand_side\": {\"entity_type\": \"app_variable\"},\n                \"right_hand_side\": {\"collection\": \"SELF_OWNED\"},\n            },\n        ]})\n    acl.append({\n        \"scope_filter_expression_list\": [\n            {\n                \"operator\": \"IN\",\n                \"left_hand_side\": \"PROJECT\",\n                \"right_hand_side\": {\"uuid_list\": [project_uuid]},\n            }\n        ],\n        \"entity_filter_expression_list\": [\n            {\n                \"operator\": \"IN\",\n                \"left_hand_side\": {\"entity_type\": \"ALL\"},\n                \"right_hand_side\": {\"collection\": collection},\n            }\n        ]})\n    return acl \n  \ndef generate_acp(role, user_details, users=None, groups=None):\n    project = @@{project_details}@@\n    user_list = user_details\n    projectUuid = project['uuid']\n    user_name = @@{project_items}@@\n    group_list = @@{group_details}@@\n\n    collection = \"SELF_OWNED\"\n    if @@{allow_collaboration}@@:\n        collection = \"ALL\"\n    role_uuid = \"@@{ROLE_OPERATOR_UUID}@@\"\n    filter_list = generate_filter_list_operator(projectUuid, collection)\n    if role == \"admin\":\n        role_uuid = \"@@{ROLE_ADMIN_UUID}@@\"\n        filter_list = generate_filter_list_admin(projectUuid, collection)\n    elif role == \"developer\":\n        role_uuid = \"@@{ROLE_DEVELOPER_UUID}@@\"\n        filter_list = generate_filter_list_developer(projectUuid, collection)\n    elif role == \"consumer\":\n        role_uuid = \"@@{ROLE_CONSUMER_UUID}@@\"\n        filter_list = generate_filter_list_consumer(projectUuid, collection)\n        \n    acp = {}\n    if groups == None:\n        _type = 'users'\n        user_reference_list = []\n        for _user in users:\n            for us in user_list:\n                if _user in us['name']:\n                    user_reference_list.append(\\\n                        {\"kind\":\"user\", \"uuid\": us['uuid']})\n        acp_list = {\n            'acp': {\n                'name': 'ACP-TENANT-{}-{}'.format(role,_type),\n                'resources': {\n                    'role_reference': {\n                        'kind': 'role',\n                        'uuid': role_uuid\n                        },\n                         \"user_reference_list\": user_reference_list,\n                         \"filter_list\": {'context_list': filter_list}\n                    },\n                    'description': 'Admin role for {}'.format(projectUuid)\n                },\n                'metadata': {\n                    'kind': 'access_control_policy'\n                },\n                'operation': 'ADD'\n            }\n        access_control_policy_list = acp_list\n    else:\n        _type = 'groups'\n        group_reference_list = []\n        for _user in groups:\n            for us in group_list:\n                if _user in us['name']:\n                    group_reference_list.append(\\\n                        {\"kind\":\"user_group\", \"uuid\": us['uuid']})\n        acp_list = {\n            'acp': {\n                'name': 'ACP-TENANT-{}-{}'.format(role, _type),\n                'resources': {\n                    'role_reference': {\n                        'kind': 'role',\n                        'uuid': role_uuid\n                        },\n                         \"user_group_reference_list\": group_reference_list,\n                         \"filter_list\": {'context_list': filter_list}\n                    },\n                    'description': 'Admin role for {}'.format(projectUuid)\n                },\n                'metadata': {\n                    'kind': 'access_control_policy'\n                },\n                'operation': 'ADD'\n            }\n        access_control_policy_list = acp_list\n    return access_control_policy_list\n\nparams = @@{project_items}@@\nupdate_project(**params)","type":"","command_line_args":"","exit_status":[],"script_type":"static"},"timeout_secs":"0","type":"EXEC","variable_list":[]}],"description":"","name":"a4e81cce_runbook","main_task_local_reference":{"kind":"app_task","name":"8ee0af0e_dag"},"variable_list":[{"regex":{"should_validate":false,"value":""},"val_type":"STRING","is_mandatory":true,"description":"","data_type":"BASE","type":"LOCAL","name":"tenant_name","value":"Nutanix_3","label":"Tenant Name","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":true,"description":"Click \"yes\" If you have already created a setup for same Tenant, and somehow it failed while creation. It will delete all existing entries for same Tenant except Active Directory. ","data_type":"BASE","type":"LOCAL","name":"delete_existing","value":"yes","label":"Delete Existing setup","attrs":{"type":"LOCAL"},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":["yes","no"]}},{"val_type":"STRING","is_mandatory":true,"description":"Example :- 10.44.46.56","data_type":"BASE","type":"LOCAL","name":"PC_IP","value":"10.44.77.68","label":"PC IP","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":true,"description":"If IDP present on PC, Please provide same IDP Name.","data_type":"BASE","type":"LOCAL","name":"idp_name","value":"Calm_IDP","label":"IDP Name","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"regex":{"should_validate":false,"value":"^(.|\\n)*$"},"val_type":"MULTILINE_STRING","is_mandatory":true,"description":"IDP Metadata XML Script ","data_type":"BASE","type":"LOCAL","name":"idp_metadata","value":"<>","label":"IDP Metadata","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":true,"description":"Should be present in given IDP. Example :- idpuser10@calmsaastest.com","data_type":"BASE","type":"LOCAL","name":"project_admin_user","value":"idpuser1@calmsaastest.com","label":"Admin User for Project","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":true,"description":"","data_type":"BASE","type":"LOCAL","name":"cluster_name","value":"auto_cluster_prod_4f4433c72b64","label":"Cluster Name","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":true,"description":"","data_type":"BASE","type":"LOCAL","name":"virtual_switch","value":"vs0","label":"Virtual Switch Name","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"regex":{"should_validate":false,"value":"^[\\d]*$"},"val_type":"INT","is_mandatory":true,"description":"","data_type":"BASE","type":"LOCAL","name":"external_vlan_id","value":"51","label":"External VLAN ID","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":true,"description":"Example :- 10.20.30.0\/24","data_type":"BASE","type":"LOCAL","name":"external_subnet_ip","value":"10.20.30.0\/24","label":"External Subnet IP with Prefix","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":true,"description":"Enter Start IP followed by End IP. Example :- 10.20.30.2-10.20.30.10","data_type":"BASE","type":"LOCAL","name":"external_subnet_ip_pool","value":"10.20.30.2-10.20.30.10","label":"External Subnet IP Pool Range","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":true,"description":"Example :- 10.20.30.1","data_type":"BASE","type":"LOCAL","name":"external_subnet_gateway_ip","value":"10.20.30.1","label":"External Subnet Gateway IP","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":true,"description":"","data_type":"BASE","type":"LOCAL","name":"external_subnet_nat","value":"True","label":"External Subnet NAT","attrs":{"type":"LOCAL"},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":["True","False"]}},{"val_type":"STRING","is_mandatory":true,"description":"Example :- 10.10.10.0\/24","data_type":"BASE","type":"LOCAL","name":"overlay_subnet_ip","value":"10.10.10.0\/24","label":"Overlay Subnet IP With Prefix","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":true,"description":"","data_type":"BASE","type":"LOCAL","name":"overlay_subnet_gateway_ip","value":"10.10.10.1","label":"Overlay Subnet Gateway IP","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":true,"description":"","data_type":"BASE","type":"LOCAL","name":"account_name","value":"NTNX_LOCAL_AZ","label":"PC Account Name for Project","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"regex":{"should_validate":false,"value":"^[\\d]*$"},"val_type":"INT","is_mandatory":true,"description":"Pass 0 (zero) if not needed.","data_type":"BASE","type":"LOCAL","name":"project_memory","value":"4","label":"Quota : Project Memory in GB","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"regex":{"should_validate":false,"value":"^[\\d]*$"},"val_type":"INT","is_mandatory":true,"description":"Pass 0 (zero) if not needed.","data_type":"BASE","type":"LOCAL","name":"project_vcpu","value":"2","label":"Quota : Project VCPUs ","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"regex":{"should_validate":false,"value":"^[\\d]*$"},"val_type":"INT","is_mandatory":true,"description":"Pass 0 (zero) if not needed.","data_type":"BASE","type":"LOCAL","name":"project_disk_size","value":"20","label":"Quota : Project Disk Size in GB","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":true,"description":"","data_type":"BASE","type":"LOCAL","name":"allow_collaboration","value":"True","label":"Allow Collaboration","attrs":{"type":"LOCAL"},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":["True","False"]}},{"val_type":"STRING","is_mandatory":true,"description":"","data_type":"BASE","type":"LOCAL","name":"create_environment","value":"yes","label":"Create Project Environment with Default Values","attrs":{"type":"LOCAL"},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":["yes","no"]}},{"val_type":"STRING","is_mandatory":true,"description":"Required only if creating environment with default values.","data_type":"BASE","type":"LOCAL","name":"environment_os","value":"Linux","label":"Environment operating system","attrs":{"type":"LOCAL"},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":["Linux","Windows"]}},{"val_type":"STRING","is_mandatory":true,"description":"Required only if creating environment with default values. Pass NA if not required.","data_type":"BASE","type":"LOCAL","name":"image_name","value":"Ubuntu-20.04.4","label":"Image Name","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"regex":{"should_validate":false,"value":"^(.|\\n)*$"},"val_type":"MULTILINE_STRING","is_mandatory":true,"description":"Should be base64 encoded for Linux and XML for Windows. Required parameter, If not creating default environment don't modify it's value. Pass NA if not creating environment with default values.","data_type":"BASE","type":"LOCAL","name":"guest_customization_script","value":"I2Nsb3VkLWNvbmZpZwp1c2VyczoKICAtIG5hbWU6IG51dGFuaXgKICAgIHNzaC1hdXRob3JpemVkLWtleXM6CiAgICAgIC0gc3NoLXJzYSBLRVkKICAgIHN1ZG86IFsnQUxMPShBTEwpIE5PUEFTU1dEOkFMTCddCiAgICBncm91cHM6IHN1ZG8KICAgIHNoZWxsOiAvYmluL2Jhc2gKCnBhY2thZ2VzOgogIC0gaHR0cGQ=","label":"Guest Customization Script","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":true,"description":"Pass NA if not creating environment with default values.","data_type":"BASE","type":"LOCAL","name":"credential_username","value":"root","label":"Environment Credential Username","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":true,"description":"","data_type":"BASE","type":"LOCAL","name":"credential_type","value":"KEY","label":"Credential Type","attrs":{"type":"LOCAL"},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":["PASSWORD","KEY"]}},{"regex":{"should_validate":false,"value":"^(.|\\n)*$"},"val_type":"MULTILINE_STRING","is_mandatory":true,"description":"Pass NA if not creating environment with default values.","data_type":"BASE","type":"LOCAL","name":"password_or_key","value":"-----BEGIN OPENSSH PRIVATE KEY-----\nb3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAAAaAAAABNlY2RzYS\n1zaGEyLW5pc3RwMjU2AAAACG5pc3RwMjU2AAAAQQR9WZPeBSvixkhjQOh9yCXXlEx5CN9M\nyh94CJJ1rigf8693gc90HmahIR5oMGHwlqMoS7kKrRw+4KpxqsF7LGvxAAAAqJZtgRuWbY\nEbAAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBH1Zk94FK+LGSGNA\n6H3IJdeUTHkI30zKH3gIknWuKB\/zr3eBz3QeZqEhHmgwYfCWoyhLuQqtHD7gqnGqwXssa\/\nEAAAAgBzKpRmMyXZ4jnSt3ARz0ul6R79AXAr5gQqDAmoFeEKwAAAAOYWpAYm93aWUubG9j\nYWwBAg==\n-----END OPENSSH PRIVATE KEY-----","label":"Password Or Key","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"regex":{"should_validate":false,"value":"^.*$"},"val_type":"STRING","is_mandatory":false,"description":"","data_type":"BASE","type":"SECRET","name":"prism_central_username","value":"Nf0ebFEUIrfRgIa\/FjafxP\/TjnagreGkQWwZtamIX72P04B83A==:utf-8","label":"Prism Central UserName","attrs":{"is_secret_modified":false,"secret_reference":{},"type":"SECRET"},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":false,"description":"","data_type":"BASE","type":"SECRET","name":"prism_central_passwd","value":"e7K+UjP4Jb0NKhAhtN1Ef1SYmcxTxln1269i48G2pEk6yz+ZOIu8ZO0WUg==:utf-8","label":"Prism Central Password","attrs":{"is_secret_modified":false,"secret_reference":{},"type":"SECRET"},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}}]}},"name":"Tenant Onboarding with IDP"},"api_version":"3.0","metadata":{"last_update_time":"1655462510510070","kind":"runbook","spec_version":143,"creation_time":"1652431108947537","name":"Tenant Onboarding with IDP"}}