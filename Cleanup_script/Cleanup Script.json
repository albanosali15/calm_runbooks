{"status":{},"spec":{"name":"Cleanup Script","description":"runbook_for_subnet","resources":{"runbook":{"name":"dc151af2_runbook","description":"","task_definition_list":[{"type":"DAG","name":"e45355be_dag","description":"","attrs":{"type":"","edges":[]},"child_tasks_local_reference_list":[{"name":"Cleanup Tenant","kind":"app_task"}],"variable_list":[],"timeout_secs":"0","retries":"0","inherit_target":false},{"type":"EXEC","name":"Cleanup Tenant","description":"","attrs":{"type":"","script":"sleep(2)\nimport requests\nfrom requests.auth import HTTPBasicAuth\n\ntenant = \"@@{tenant_name}@@\".strip()\nmanagement_cluster_info = {\n    \"username\": \"@@{management_pc_username}@@\".strip(),\n    \"password\": \"@@{management_pc_password}@@\".strip(),\n    \"ip\": \"@@{management_pc_ip}@@\".strip()\n}\nworkload_cluster_info = {\n    \"username\": \"@@{prism_central_username}@@\".strip(),\n    \"password\": \"@@{prism_central_passwd}@@\".strip(),\n    \"ip\": \"@@{PC_IP}@@\".strip()\n}\n\nvpc_name = \"{}_VPC\".format(tenant)\nexternal_subnet_name = \"{}_External_Subnet\".format(tenant)\noverlay_subnet_name = \"{}_Overlay_Subnet\".format(tenant)\nproject_name = \"{}_project\".format(tenant)\ntunnel_name = \"@@{tenant_name}@@\"+\"_VPC_Tunnel\"\n\ndef _build_url(scheme, resource_type, host, **params):\n    _base_url = \"\/api\/nutanix\/v3\"\n    url = \"{proto}:\/\/{host}\".format(proto=scheme, host=host)\n    port = params.get('nutanix_port', '9440')\n    if port:\n        url = url + \":{0}\".format(port) + _base_url\n    if resource_type.startswith(\"\/\"):\n        url += resource_type\n    else:\n        url += \"\/{0}\".format(resource_type)\n    return url\n\ndef _get_tunnel_uuid(tunnel_name, host):\n    tunnel_state = [\"CONNECTING\",\"NOT_VALIDATED\" ]\n    url = _build_url(scheme=\"https\",resource_type=\"\/tunnels\/list\",host=host.get(\"ip\"))\n    data = requests.post(url, json={\"kind\": \"tunnel\",\"filter\":\"name==%s\"%tunnel_name},\n                         auth=HTTPBasicAuth(host.get(\"username\"),\n                                            host.get(\"password\")),\n                                            timeout=None,\n                                            verify=False)\n    if data.ok:\n        if data.json()['metadata']['total_matches'] == 0:\n            print(\"%s does not exist\"%(tunnel_name))\n        elif data.json()['metadata']['total_matches'] > 1:\n            print(\"There are more than one tunnel with name - %s\"%(tunnel_name))\n            print(\"Please delete it manually before executing runbook.\")\n            exit(1)\n        elif data.json()['entities'][0]['status']['state'] in tunnel_state:\n            print(\"tunnel is in NOT_VALIDATED,Please delete it manually before executing runbook.\")\n            exit(1)\n        else:\n            tunnel_uuid = data.json()['entities'][0]['status']['resources']['uuid']\n            return tunnel_uuid\n    else:\n        print(\"Error while fetching tunnel details :- \",data.json().get('message_list',\n                                     data.json().get('error_detail', data.json())))\n        exit(1)\n\ndef _get_network_group_uuid(tunnel_name, host):\n    url = _build_url(scheme=\"https\",resource_type=\"\/network_groups\/list\",host=host.get(\"ip\"))\n    data = requests.post(url, json={\"kind\": \"network_group\",\"filter\":\"name==%s\"%tunnel_name},\n                         auth=HTTPBasicAuth(host.get(\"username\"),\n                                            host.get(\"password\")),\n                         timeout=None, verify=False)\n    if data.ok:\n        if data.json()['metadata']['total_matches'] == 0:\n            print(\"%s does not exist\"%(tunnel_name))\n        else:\n            group_uuid = data.json()['entities'][0]['status']['resources']['uuid']\n            return group_uuid\n    else:\n        print(\"Error while fetching network group details :- \",data.json().get('message_list',\n                                     data.json().get('error_detail', data.json())))\n        exit(1)\n\n\ndef delete_tunnel(tunnel_name, host):\n    print(\"Fetching tunnel details:{}\".format(tunnel_name))\n    tunnel_name = tunnel_name.strip()\n    _group_uuid = _get_network_group_uuid(tunnel_name, host)\n    _tunnel_uuid = _get_tunnel_uuid(tunnel_name, host)\n    if _group_uuid:\n        url = _build_url(scheme=\"https\",resource_type=\"network_groups\/{}\/tunnels\/{}\".format(_group_uuid, _tunnel_uuid),\n                         host = host.get(\"ip\"), username=host.get(\"username\"), password=host.get(\"password\"))\n        data = requests.delete(url, auth=HTTPBasicAuth(host.get(\"username\"), host.get(\"password\")),\n                               timeout=None, verify=False)\n\n        print(\"deleting tunnel with name %s\"%tunnel_name)\n    else:\n        print(\"Info : %s tunnel not present on Management PC\"%(tunnel_name))\n\ndef get_entity_uuid(resource_type, name, host, filter=None):\n    ip = host.get(\"ip\")\n    username = host.get(\"username\")\n    password = host.get(\"password\")\n    if not filter:\n        filter = \"name=={0}\".format(name)\n    payload = {\"filter\": filter}\n    url = _build_url(scheme=\"https\",resource_type=\"\/{0}\/list\".format(resource_type), host=ip)\n    data = requests.post(url, json=payload,\n                        auth=HTTPBasicAuth(username, password),verify=False)\n    if data.ok:\n        if data.json().get(\"metadata\", {}).get(\"total_matches\", 0) > 0:\n            for entity in data.json().get(\"entities\", []):\n                return entity.get('metadata', {}).get('uuid'), None\n        else:\n            return None, \"{0} with name {1} not found\".format(resource_type, name)\n    else:\n        msg = \"Failed to fetch {0} details. \".format(name) + data.json()\n        return None, msg\n\ndef delete_vpc(vpc_name, host):\n    print(\"Fetching %s VPC information...\"%vpc_name)\n    vpc_name = vpc_name.strip()\n    uuid, err = get_entity_uuid(\"vpcs\", vpc_name, host)\n    if err:\n        print(\"Info : %s VPC not present on %s. \"%(vpc_name, host.get(\"ip\")), err)\n        return\n\n    ip = host.get(\"ip\")\n    username = host.get(\"username\")\n    password = host.get(\"password\")\n    url = _build_url(scheme=\"https\", resource_type=\"\/vpcs\/%s\"%uuid, host=ip)\n    data = requests.delete(url, auth=HTTPBasicAuth(username, password),\n                            timeout=None, verify=False)\n    wait_for_completion(data, username, password, ip)\n    print(\"%s VPC deleted successfully.\"%vpc_name)\n\ndef delete_subnet(subnet_name, host):\n    print(\"Fetching %s subnet information...\"%subnet_name)\n    subnet_name = subnet_name.strip()\n    uuid, err = get_entity_uuid(\"subnets\", subnet_name, host)\n    if err:\n        print(\"Info : %s Subnet not present on %s. \"%(subnet_name, host.get(\"ip\")), err)\n        return\n\n    ip = host.get(\"ip\")\n    username = host.get(\"username\")\n    password = host.get(\"password\")\n    url = _build_url(scheme=\"https\", resource_type=\"\/subnets\/%s\"%uuid, host=ip)\n    data = requests.delete(url, auth=HTTPBasicAuth(username, password),\n                            timeout=None, verify=False)\n    wait_for_completion(data, username, password, ip)\n    print(\"%s Subnet deleted successfully.\"%vpc_name)\n\n\ndef delete_project(project_name, host):\n    print(\"Deleting project %s\"%project_name)\n    ip = host.get(\"ip\")\n    username = host.get(\"username\")\n    password = host.get(\"password\")\n    project_name = project_name.strip()\n    _uuid, err = get_entity_uuid(\"projects\", project_name, host)\n    if err:\n        print(\"Info : %s Project not present on %s. \"%(project_name, host.get(\"ip\")), err)\n        exit(1)\n    url = _build_url(scheme=\"https\", host=ip,resource_type=\"\/projects\/%s\"%_uuid)\n    data = requests.delete(url, auth=HTTPBasicAuth(username,\n                                                   password),\n                           timeout=None, verify=False)\n    wait_for_completion(data, username, password, ip)\n    print(\"%s Project deleted successfully.\"%project_name)\n\ndef delete_app_protection_policies(project_name, host):\n    print(\"Fetching app protection policies information...\")\n    project_uuid, err = get_entity_uuid(\"projects\", project_name, host)\n    if err:\n        print(\"Info : %s Project not present on %s. \"%(project_name, host.get(\"ip\")), err)\n        exit(1)\n    ip = host.get(\"ip\")\n    username = host.get(\"username\")\n    password = host.get(\"password\")\n    url = \"https:\/\/{0}:9440\/api\/calm\/v3.0\/app_protection_policies\/list\".format(ip)\n    data = requests.post(url, json={\"filter\":\"project_reference==%s\"%project_uuid,\"length\":20},\n                         auth=HTTPBasicAuth(username,\n                                            password),\n                           timeout=None, verify=False)\n    uuid_list = []\n    if data.ok:\n        if data.json()[\"metadata\"][\"total_matches\"] > 0:\n            for _policy in data.json()[\"entities\"]:\n                uuid_list.append(_policy[\"metadata\"][\"uuid\"])\n        else:\n            print(\"Info : No App protection policies present on Localhost for %s\"%project_name)\n    else:\n        print(\"Failed to fetch app protection policies for %s project.\"%project_name)\n        print(data.json())\n        exit(1)\n\n    for _uuid in uuid_list:\n        url = \"https:\/\/{0}:9440\/api\/calm\/v3.0\/app_protection_policies\/{1}\".format(ip, _uuid)\n        data = requests.delete(url, auth=HTTPBasicAuth(username,\n                                                       password),\n                               timeout=None, verify=False)\n        if data.ok:\n            if \"App protection policy with uuid %s deleted\"%_uuid not in data.json()[\"description\"]:\n                print(\"Failed to delete App snapshot policy.\",data.json())\n                exit(1)\n        else:\n            print(\"Error while deleting App snapshot policy.\")\n            print(data.json().get('message_list',data.json().get('error_detail', data.json())))\n            exit(1)\n\n    if uuid_list != []:\n        print(\"App protection policies for %s Project deleted successfully.\"%project_name)\n\n\ndef fetch_entities_uuid_associated_to_project(resource_type, project_name, host):\n    uuids = []\n    limit = 20\n    offset = 0\n    auth = HTTPBasicAuth(host.get(\"username\"), host.get(\"password\"))\n    while(True):\n        url = _build_url(scheme=\"https\", host=host.get(\"ip\"),resource_type=\"\/%s\/list\"%resource_type)\n        data = requests.post(url, json={\"length\": limit, \"offset\": offset},\n                             auth=auth,\n                             timeout=None, verify=False)\n        if data.ok:\n            if len(data.json().get(\"entities\", [])) > 0:\n                for _entity in data.json()[\"entities\"]:\n                    if _entity[\"metadata\"][\"project_reference\"][\"name\"] == project_name:\n                        uuids.append(_entity[\"metadata\"][\"uuid\"])\n            else:\n                break\n        else:\n            print(\"Failed fetching {0} for project {1}:\".format(resource_type, project_name), data.json())\n            exit(1)\n        offset += limit\n    return uuids\n\ndef delete_applications(project_name, host):\n    print(\"Fetching applications information...\")\n    project_name = project_name.strip()\n    uuids = fetch_entities_uuid_associated_to_project(\"apps\", project_name, host)\n    if not uuids:\n        print(\"No applications associated to project with name %s\"%project_name)\n        return\n    ip = host.get(\"ip\")\n    username = host.get(\"username\")\n    password = host.get(\"password\")\n    for _uuid in uuids:\n        url = _build_url(scheme=\"https\", host=ip,resource_type=\"\/apps\/%s\"%_uuid)\n        data = requests.delete(url, auth=HTTPBasicAuth(username,\n                                                       password),\n                               timeout=None, verify=False)\n        task_uuid = data.json()[\"status\"][\"ergon_task_uuid\"]\n        wait_for_completion(data, username, password, ip, task_uuid)\n    print(\"Applications deleted successfully.\")\n\ndef delete_blueprints(project_name, host):\n    print(\"Fetching blueprints information...\")\n    project_name = project_name.strip()\n    ip = host.get(\"ip\")\n    username = host.get(\"username\")\n    password = host.get(\"password\")\n    uuids = fetch_entities_uuid_associated_to_project(\"blueprints\", project_name, host)\n    if not uuids:\n        print(\"No applications associated to project with name %s\"%project_name)\n        return\n    for _uuid in uuids:\n        url = _build_url(scheme=\"https\", host=ip,resource_type=\"\/blueprints\/%s\"%_uuid)\n        data = requests.delete(url, auth=HTTPBasicAuth(username,\n                                                       password),\n                               timeout=None, verify=False)\n        if not data.ok:\n            print(\"Failed to delete blueprints\", data.json())\n            exit(1)\n\n    print(\"Blueprints deleted successfully.\")\n\ndef delete_project_environment(project_name, host):\n    print(\"Fetching project environments information...\")\n    project_name = project_name.strip()\n    ip = host.get(\"ip\")\n    username = host.get(\"username\")\n    password = host.get(\"password\")\n    url = _build_url(scheme=\"https\", host=ip,resource_type=\"\/environments\/list\")\n    data = requests.post(url, json={\"kind\":\"environment\"},\n                         auth=HTTPBasicAuth(username,\n                                            password),\n                           timeout=None, verify=False)\n    uuid_list = []\n    if data.ok:\n        if data.json()[\"metadata\"].get(\"total_matches\") > 0:\n            for _env in data.json()[\"entities\"]:\n                if \"project_reference\" in _env[\"metadata\"].keys():\n                    if _env[\"metadata\"][\"project_reference\"][\"name\"] == project_name:\n                        uuid_list.append(_env[\"metadata\"][\"uuid\"])\n        else:\n            print(\"Info : No environment found on localhost\")\n    else:\n        print(\"Failed to fetch environment details.\")\n        print(data.json().get('message_list',data.json().get('error_detail', data.json())))\n        exit(1)\n\n    for _uuid in uuid_list:\n        url = _build_url(scheme=\"https\", host=ip,resource_type=\"\/environments\/%s\"%_uuid)\n        data = requests.delete(url,auth=HTTPBasicAuth(username,\n                                                  password),\n                           timeout=None, verify=False)\n        if data.ok:\n            if \"Environment with uuid %s deleted\"%_uuid not in data.json()[\"description\"]:\n                print(\"Failed to project environment.\",data.json())\n                exit(1)\n        else:\n            print(\"Error while deleting project environment.\")\n            print(data.json().get('message_list',data.json().get('error_detail', data.json())))\n            exit(1)\n\n    if uuid_list != []:\n        print(\"%s Project environment with %s uuid's deleted successfully.\"%(project_name, uuid_list))\n\ndef wait_for_completion(data, user, password, PC, task_uuid=None):\n    if data.ok:\n        state = \"DELETE_PENDING\"\n        while state == \"DELETE_PENDING\":\n            if task_uuid == None:\n                task_uuid = data.json()['status']['execution_context']['task_uuid']\n            url = _build_url(scheme=\"https\",host=PC,\n                             resource_type=\"\/tasks\/%s\"%task_uuid)\n            responce = requests.get(url, auth=HTTPBasicAuth(user, password),\n                                    verify=False)\n            if responce.json().get('status', None) in ['DELETE_PENDING', 'RUNNING', 'QUEUED']:\n                state = 'DELETE_PENDING'\n                sleep(5)\n            elif responce.json().get('status', None) == 'FAILED':\n                print(\"Error ---> \",responce.json().get('message_list',\n                                        responce.json().get('error_detail', responce.json())))\n                state = 'FAILED'\n                exit(1)\n            else:\n                state = \"COMPLETE\"\n    else:\n        print(\"Error ---> \",data.json().get('message_list',\n                                data.json().get('error_detail', data.json())))\n        exit(1)\n\nif \"@@{delete_only_network}@@\" == \"False\":\n    try:\n        # clear entities from management cluster\n        delete_applications(project_name, host=management_cluster_info)\n        delete_blueprints(project_name, host=management_cluster_info)\n        delete_app_protection_policies(project_name, host=management_cluster_info)\n        delete_tunnel(tunnel_name, host=management_cluster_info)\n        delete_project_environment(project_name, host=management_cluster_info)\n        delete_project(project_name, host=management_cluster_info)\n\n        # clear entities from workload cluster\n        delete_subnet(overlay_subnet_name, host=workload_cluster_info)\n        delete_vpc(vpc_name, host=workload_cluster_info)\n        delete_subnet(external_subnet_name, host=workload_cluster_info)\n    except Exception as e:\n      raise e\nelse:\n    try:\n        # clear entities from management cluster\n        delete_tunnel(tunnel_name, host=management_cluster_info)\n\n        # clear entities from workload cluster\n        delete_subnet(overlay_subnet_name, host=workload_cluster_info)\n        delete_vpc(vpc_name, host=workload_cluster_info)\n        delete_subnet(external_subnet_name, host=workload_cluster_info)\n    except Exception as e:\n      raise e\n","script_type":"static_py3","command_line_args":"","exit_status":[]},"child_tasks_local_reference_list":[],"variable_list":[],"timeout_secs":"0","retries":"0","inherit_target":false}],"main_task_local_reference":{"name":"e45355be_dag","kind":"app_task"},"variable_list":[{"type":"LOCAL","name":"management_pc_ip","description":"Management Prism Cental IP","options":{"type":"PREDEFINED","choices":[]},"is_hidden":false,"is_mandatory":true,"data_type":"BASE","val_type":"STRING","label":"Management PC IP","attrs":{"type":""},"editables":{"value":true},"value":"10.44.76.42"},{"type":"SECRET","name":"management_pc_username","description":"","options":{"type":"PREDEFINED","choices":[]},"is_hidden":false,"is_mandatory":true,"data_type":"BASE","val_type":"STRING","label":"Management PC Username","attrs":{"type":"SECRET","is_secret_modified":false,"secret_reference":{}},"editables":{"value":true},"value":"MpBpr4XuD1IJCTO2BEjpoGQiZMjPujMpycRAeKXIGByh:utf-8"},{"type":"SECRET","name":"management_pc_password","description":"","options":{"type":"PREDEFINED","choices":[]},"is_hidden":false,"is_mandatory":true,"data_type":"BASE","val_type":"STRING","label":"Management PC Password","attrs":{"type":"SECRET","is_secret_modified":false,"secret_reference":{}},"editables":{"value":true},"value":"KkkaYB2NmRbj+FykZA6XIcHIFh\/p89xRLm3zg3onNRYb:utf-8"},{"type":"LOCAL","name":"tenant_name","description":"","options":{"type":"PREDEFINED","choices":[]},"is_hidden":false,"is_mandatory":true,"data_type":"BASE","val_type":"STRING","label":"Tenant Name","attrs":{"type":""},"editables":{"value":true},"value":"My_Tenant"},{"type":"LOCAL","name":"delete_only_network","description":"It will delete subnets and VPC if those are not used in project.","options":{"type":"PREDEFINED","choices":["True","False"]},"is_hidden":false,"is_mandatory":true,"data_type":"BASE","val_type":"STRING","label":"Delete only network configuration","attrs":{"type":"LOCAL"},"editables":{"value":true},"value":"False"},{"type":"LOCAL","name":"PC_IP","description":"Prism Central IP","options":{"type":"PREDEFINED","choices":[]},"is_hidden":false,"is_mandatory":true,"data_type":"BASE","val_type":"STRING","label":"Workload PC IP","attrs":{"type":""},"editables":{"value":true},"value":"10.51.144.22"},{"type":"SECRET","name":"prism_central_username","description":"","options":{"type":"PREDEFINED","choices":[]},"is_hidden":false,"is_mandatory":true,"data_type":"BASE","val_type":"STRING","label":"Workload PC Username","attrs":{"type":"SECRET","is_secret_modified":false,"secret_reference":{}},"editables":{"value":true},"value":"0Vu6AGVPhWRHkddyYi2+0qfKtZnmZ8u6aP2RHOWo+fLk:utf-8"},{"type":"SECRET","name":"prism_central_passwd","description":"","regex":{"value":"^.*$","should_validate":false},"options":{"type":"PREDEFINED","choices":[]},"is_hidden":false,"is_mandatory":true,"data_type":"BASE","val_type":"STRING","label":"Workload PC Password","attrs":{"type":"SECRET","is_secret_modified":false,"secret_reference":{}},"editables":{"value":true},"value":"8DZg62XwxFz9ilbkk8sle+kjxEiWSaMdxZgOzu\/8siNn:utf-8"}]},"endpoint_definition_list":[],"credential_definition_list":[],"endpoints_information":[],"client_attrs":{}}},"api_version":"3.0","product_version":"3.8.0","metadata":{"last_update_time":"1714742717441563","creation_time":"1714726007567919","spec_version":19,"name":"Cleanup Script","kind":"runbook"},"contains_secrets":true}
