{"status":{},"contains_secrets":true,"product_version":"3.6.0","spec":{"description":"","resources":{"endpoints_information":[],"endpoint_definition_list":[],"client_attrs":{},"credential_definition_list":[],"runbook":{"task_definition_list":[{"retries":"0","description":"","inherit_target":false,"child_tasks_local_reference_list":[{"kind":"app_task","name":"Precheck Validation"},{"kind":"app_task","name":"Create External Subnet"},{"kind":"app_task","name":"Create VPC"},{"kind":"app_task","name":"Create Overlay Subnet"}],"name":"8ee0af0e_dag","attrs":{"edges":[{"from_task_reference":{"kind":"app_task","name":"Create External Subnet"},"edge_type":"user_defined","type":"","to_task_reference":{"kind":"app_task","name":"Create VPC"}},{"from_task_reference":{"kind":"app_task","name":"Create VPC"},"edge_type":"user_defined","type":"","to_task_reference":{"kind":"app_task","name":"Create Overlay Subnet"}},{"from_task_reference":{"kind":"app_task","name":"Precheck Validation"},"edge_type":"user_defined","type":"","to_task_reference":{"kind":"app_task","name":"Create External Subnet"}}],"type":""},"timeout_secs":"0","type":"DAG","variable_list":[]},{"retries":"0","description":"","inherit_target":false,"child_tasks_local_reference_list":[],"name":"Precheck Validation","attrs":{"exit_status":[],"script":"# script\n\nimport requests\nfrom requests.auth import HTTPBasicAuth\n\nPC_IP = \"@@{PC_IP}@@\".strip()\npc_username = \"@@{prism_central_username}@@\".strip()\npc_password = \"@@{prism_central_passwd}@@\".strip()\nskip_delete = False\n\ndef _build_url(scheme, resource_type, host=PC_IP, **params):\n    _base_url = \"\/api\/nutanix\/v3\"\n    url = \"{proto}:\/\/{host}\".format(proto=scheme, host=host)\n    port = params.get('nutanix_port', '9440')\n    if port:\n        url = url + \":{0}\".format(port) + _base_url\n    if resource_type.startswith(\"\/\"):\n        url += resource_type\n    else:\n        url += \"\/{0}\".format(resource_type)\n    return url\n\ndef _get_cluster_details(cluster_name):\n    payload = {\"kind\": \"cluster\"}\n    url = _build_url(scheme=\"https\",\n                    resource_type=\"\/clusters\/list\")\n    data = requests.post(url, json=payload,\n                         auth=HTTPBasicAuth(pc_username, pc_password), \n                         verify=False)\n    if data.ok:\n        for _cluster in data.json()['entities']:\n            if _cluster['status']['name'] == cluster_name:\n                print(\"cluster_uuid={}\".format(_cluster['metadata']['uuid']))\n                return str(_cluster['metadata']['uuid'])\n        print(\"Input Error :- Given cluster %s not present on %s\"%(cluster_name, PC_IP))\n        exit(1)\n    else:\n        print(\"Error while fetching %s cluster info\"%cluster_name)\n        print(data.json().get('message_list',data.json().get('error_detail', data.json())))\n        exit(1)\n            \ndef _get_virtual_switch_uuid(virtual_switch_name, cluster_uuid): \n    payload = {\"entity_type\": \"distributed_virtual_switch\", \n               \"filter\": \"name==%s\"%virtual_switch_name}\n    url = _build_url(scheme=\"https\",\n                    resource_type=\"\/groups\")                \n    data = requests.post(url, json=payload,\n                         auth=HTTPBasicAuth(pc_username, pc_password),\n                         verify=False)\n    if data.ok:\n        _uuid = data.json()['group_results'][0]['entity_results'][0]['entity_id']\n        _url = \"https:\/\/%s:9440\/api\/networking\/v2.a1\/dvs\/virtual-switches\/%s?proxyClusterUuid=%s\"%(PC_IP,\n                                                                                                _uuid,\n                                                                                                cluster_uuid)\n        _data = requests.get(_url, auth=HTTPBasicAuth(pc_username, pc_password),verify=False)\n        if _data.json()['data']['name'] == virtual_switch_name:\n            print(\"virtual switch uuid ----> \",_uuid)\n            return str(_uuid)\n        else:\n            print(\"Input Error :- %s virtual switch not present on %s\"%(virtual_switch_name, PC_IP))\n            exit(1)\n    else:\n        print(\"Error while fetching virtual switch details :- \",data.json().get('message_list',\n                                                                                data.json().get('error_detail', \n                                                                                data.json())))\n\ndef _get_subnet_uuid(subnet, delete=False):\n    global skip_delete\n    url = _build_url(scheme=\"https\",resource_type=\"\/subnets\/list\")\n    data = requests.post(url, json={\"kind\":\"subnet\", \"filter\":\"name==%s\"%subnet},\n                         auth=HTTPBasicAuth(pc_username, \n                                            pc_password),\n                         timeout=None, verify=False)\n    if data.ok:\n        if data.json()['metadata']['total_matches'] == 0:\n            print(\"%s not present on %s\"%(subnet, PC_IP))\n            skip_delete = True\n            if not delete:\n                exit(1)\n        elif data.json()['metadata']['total_matches'] > 1:\n            print(\"There are more than one subnets with name - %s on - %s\"%(subnet, PC_IP))\n            print(\"Please delete it manually before executing runbook.\")\n            exit(1)\n        else:\n            skip_delete = False\n            return data.json()['entities'][0]['metadata']['uuid']\n    else:\n        print(\"Error while fetching subnet details :- \",data.json().get('message_list',\n                                     data.json().get('error_detail', data.json())))\n        exit(1)\n        \ndef _get_vpc_uuid(vpc_name):\n    global skip_delete\n    url = _build_url(scheme=\"https\",resource_type=\"\/vpcs\/list\")\n    data = requests.post(url, json={\"kind\":\"vpc\", \"filter\":\"name==%s\"%vpc_name},\n                         auth=HTTPBasicAuth(pc_username, \n                                            pc_password),\n                         timeout=None, verify=False)\n    if data.ok:\n        if data.json()['metadata']['total_matches'] == 0:\n            print(\"%s not present on %s\"%(vpc_name, PC_IP))\n            skip_delete = True\n        elif data.json()['metadata']['total_matches'] > 1:\n            print(\"There are more than one VPC's with name - %s on - %s\"%(vpc_name, PC_IP))\n            print(\"Please delete it manually before executing runbook.\")\n            exit(1)\n        else:\n            skip_delete = False\n            return data.json()['entities'][0]['metadata']['uuid']\n    else:\n        print(\"Error while fetching VPC details :- \",data.json().get('message_list',\n                                     data.json().get('error_detail', data.json())))\n        exit(1)\n        \ndef wait_for_completion(data):\n    if data.ok:\n        state = data.json()['status'].get('state')\n        while state == \"DELETE_PENDING\":\n            _uuid = data.json()['status']['execution_context']['task_uuid']\n            url = _build_url(scheme=\"https\",\n                             resource_type=\"\/tasks\/%s\"%_uuid)\n            responce = requests.get(url, auth=HTTPBasicAuth(pc_username, pc_password), \n                                    verify=False)\n            if responce.json()['status'] in ['DELETE_PENDING']:\n                state = 'DELETE_PENDING'\n                sleep(5)                \n            elif responce.json()['status'] == 'FAILED':\n                print(\"Got Error ---> \",responce.json().get('message_list', \n                                        responce.json().get('error_detail', responce.json())))\n                state = 'FAILED'\n                exit(1)\n            else:\n                state = \"COMPLETE\" \n    else:\n        print(\"Got Error ---> \",data.json().get('message_list', \n                                data.json().get('error_detail', data.json())))\n        exit(1)\n        \ndef _get_ip(IP):\n    ip_list = IP.split(\".\")\n    gatewat_digit = int(ip_list[-1]) + 1\n    start_digit = gatewat_digit + 1\n    end_digit = start_digit + 50\n    gateway_ip = ip_list[:3]\n    gateway_ip.append(str(gatewat_digit))\n    gateway_ip = \".\".join(gateway_ip)\n    start_ip = ip_list[:3]\n    start_ip.append(str(start_digit))\n    start_ip = \".\".join(start_ip)\n    end_ip = ip_list[:3]\n    end_ip.append(str(end_digit))\n    end_ip = \".\".join(end_ip)\n    return (gateway_ip, start_ip, end_ip)\n    \nexternal_subnet_items = {}\nvpc_items = {}\noverlay_subnet_items = {}\n\n\n#tenant = \"@@{tenant_name}@@\"\ncluster = \"@@{cluster_name}@@\".strip()\ncluter_uuid = _get_cluster_details(cluster)\nif @@{create_external_subnet}@@:\n    for x in [ \"@@{external_subnet_ip}@@\".strip(), \"@@{external_subnet_name}@@\".strip(),\n               \"@@{virtual_switch}@@\".strip(), \"@@{external_subnet_gateway_ip}@@\".strip(),\n                \"@@{external_subnet_ip_pool}@@\"]:\n        if x.lower() in [\"\", \"none\", \"na\"]:\n            print(\"Input Error :- Need all required parameters to create External Subnet as shown below.\")\n            print(\"External Subnet Name, External VLAN ID, External Subnet IP with Prefix, \"\\\n                  \"External Subnet IP Pool Range, External Subnet Gateway IP\")\n            exit(1)\n            \n    external_subnet = \"@@{external_subnet_ip}@@\".strip()\n    if \"\/\" not in external_subnet:\n        print(\"Input Error :-- External subnet IP with Prefix should be in below format.\")\n        print(\"10.10.10.0\/24\")\n        exit(1)\n    external_subnet_ip, external_subnet_prefix = external_subnet.split(\"\/\")\n    external_subnet_items['name'] = \"@@{external_subnet_name}@@\".strip()\n    external_subnet_items['cluster'] = cluster\n    external_subnet_items['enable_nat'] = @@{external_subnet_nat}@@\n    external_subnet_items['virtual_switch_name'] = \"@@{virtual_switch}@@\".strip()\n    _uuid = _get_virtual_switch_uuid(external_subnet_items['virtual_switch_name'], cluter_uuid)\n    external_subnet_items['gateway_ip'] = \"@@{external_subnet_gateway_ip}@@\".strip()\n    external_subnet_items['network_ip'] = external_subnet_ip\n    external_subnet_items['prefix'] = int(external_subnet_prefix)\n    IP_POOL = \"@@{external_subnet_ip_pool}@@\".split(\"-\")\n    external_subnet_items['ip_pools'] = {\"range\":\"%s %s\"%(IP_POOL[0],IP_POOL[1])}\n    print(\"external_subnet_items={}\".format(external_subnet_items))\nelse:\n    print(\"external_subnet_items=False\")\n\nif @@{create_vpc}@@:\n    vpc_items['name'] = \"@@{vpc_name}@@\".strip()\n    vpc_items['external_subnet_name'] = \"@@{external_subnet_name}@@\".strip()\n    print(\"vpc_items={}\".format(vpc_items))\nelse:\n    print(\"vpc_items=False\")\n\nif @@{create_overlay_subnet}@@:\n    for x in [\"@@{overlay_subnet_ip}@@\".strip(), \"@@{overlay_subnet_name}@@\".strip(),\n              \"@@{overlay_subnet_gateway_ip}@@\".strip()]:\n        if x.lower() in [\"\", \"none\", \"na\"]:\n            print(\"Input Error :- Need all required parameters to create Overlay Subnet as shown below.\")\n            print(\"Overlay Subnet Name, Overlay Subnet IP With Prefix, Overlay Subnet Gateway IP\")\n            exit(1)\n            \n    overlay_subnet = \"@@{overlay_subnet_ip}@@\".strip()\n    if \"\/\" not in overlay_subnet:\n        print(\"Input Error :-- Overlay subnet IP with Prefix should be in below format.\")\n        print(\"10.10.10.0\/24\")\n        exit(1)\n        \n    overlay_subnet_ip, overlay_subnet_prefix = overlay_subnet.split(\"\/\")\n    overlay_subnet_items['subnet_name'] = \"@@{overlay_subnet_name}@@\".strip()\n    overlay_subnet_items['vpc_name'] = \"@@{vpc_name}@@\".strip()\n    overlay_subnet_items['network_ip'] = overlay_subnet_ip\n    overlay_subnet_items['prefix'] = int(overlay_subnet_prefix)\n    overlay_subnet_items['gateway_ip'] = \"@@{overlay_subnet_gateway_ip}@@\".strip()\n    IP = _get_ip(overlay_subnet_ip)\n    overlay_subnet_items['ip_pool'] = [{\"ip_pools_start_ip\":IP[1], \n                                     \"ip_pools_end_ip\":IP[2]}]\n    print(\"overlay_subnet_items={}\".format(overlay_subnet_items))\nelse:\n    print(\"overlay_subnet_items=False\")","eval_variables":["external_subnet_items","vpc_items","overlay_subnet_items","cluster_uuid"],"eval_scope":"local","type":"","script_type":"static"},"timeout_secs":"0","type":"SET_VARIABLE","variable_list":[]},{"retries":"0","description":"","inherit_target":false,"child_tasks_local_reference_list":[],"name":"Create External Subnet","attrs":{"exit_status":[],"script":"#script\n\nimport requests\nfrom requests.auth import HTTPBasicAuth\n\nPC_IP = \"@@{PC_IP}@@\".strip()\npc_username = \"@@{prism_central_username}@@\".strip()\npc_password = \"@@{prism_central_passwd}@@\".strip()\n\ndef _build_url(scheme, resource_type, host=PC_IP, **params):\n    _base_url = \"\/api\/nutanix\/v3\"\n    url = \"{proto}:\/\/{host}\".format(proto=scheme, host=host)\n    port = params.get('nutanix_port', '9440')\n    if port:\n        url = url + \":{0}\".format(port) + _base_url\n    if resource_type.startswith(\"\/\"):\n        url += resource_type\n    else:\n        url += \"\/{0}\".format(resource_type)\n    return url\n  \ndef _get_cluster_details(cluster_name):\n    cluster_details = {'kind':'cluster'}\n    payload = {\"kind\": \"cluster\"}\n    url = _build_url(scheme=\"https\",\n                    resource_type=\"\/clusters\/list\")\n    data = requests.post(url, json=payload,\n                         auth=HTTPBasicAuth(pc_username, pc_password), \n                         verify=False)\n    if data.ok:\n        for _cluster in data.json()['entities']:\n            if _cluster['status']['name'] == cluster_name:\n                cluster_details['uuid'] = str(_cluster['metadata']['uuid'])\n                return cluster_details\n        print(\"Input Error :- Given cluster %s not present on %s\"%(cluster_name, PC_IP))\n        exit(1)\n    else:\n        print(\"Error while fetching %s cluster info\"%cluster_name)\n        print(data.json().get('message_list',data.json().get('error_detail', data.json())))\n        exit(1)\n    \ndef _get_virtual_switch_uuid(virtual_switch_name):\n    cluster = \"@@{cluster_name}@@\".strip()\n    _cluster = _get_cluster_details(cluster)\n    cluster_uuid = _cluster['uuid']\n    payload = {\"entity_type\": \"distributed_virtual_switch\", \n               \"filter\": \"name==%s\"%virtual_switch_name}\n    url = _build_url(scheme=\"https\",\n                    resource_type=\"\/groups\")                \n    data = requests.post(url, json=payload,\n                         auth=HTTPBasicAuth(pc_username, pc_password),\n                         verify=False)\n    if data.ok:\n        _uuid = data.json()['group_results'][0]['entity_results'][0]['entity_id']\n        _url = \"https:\/\/%s:9440\/api\/networking\/v2.a1\/dvs\/virtual-switches\/%s?proxyClusterUuid=%s\"%(PC_IP,\n                                                                                                _uuid,\n                                                                                                cluster_uuid)\n        _data = requests.get(_url, auth=HTTPBasicAuth(pc_username, pc_password),verify=False)\n        if _data.json()['data']['name'] == virtual_switch_name:\n            print(\"virtual switch uuid ----> \",_uuid)\n            return str(_uuid)\n        else:\n            print(\"Input Error :- %s virtual switch not present on %s\"%(virtual_switch_name, PC_IP))\n            exit(1)\n    else:\n        print(\"Error while fetching virtual switch details :- \",data.json().get('message_list',\n                                                                                data.json().get('error_detail', \n                                                                                data.json())))\n\ndef _get_default_spec():\n    return (\n        {\n          \"api_version\": \"3.1.0\",\n          \"metadata\": {\"kind\": \"subnet\"},\n          \"spec\": {\n                  \"name\": \"\",\n                  \"resources\": {\n                      \"ip_config\": {},\n                      \"subnet_type\": None,\n                      },\n                  },\n              }\n          )\n\ndef _get_ipam_spec(**params):\n    ipam_spec = {}\n    if params['set_ipam'] == 'yes':\n        ipam_spec = _get_default_ipconfig_spec()\n        ipam_config = params[\"ipam\"]\n        ipam_spec[\"subnet_ip\"] = ipam_config[\"network_ip\"]\n        ipam_spec[\"prefix_length\"] = ipam_config[\"network_prefix\"]\n        ipam_spec[\"default_gateway_ip\"] = ipam_config[\"gateway_ip\"]\n        pools = []\n        pools.append(params[\"ip_pools\"])\n        ipam_spec[\"pool_list\"] = pools\n    return ipam_spec\n\ndef _get_default_ipconfig_spec():\n    return (\n        {\n         \"subnet_ip\": None,\n         \"prefix_length\": None,\n         \"default_gateway_ip\": None,\n         \"pool_list\": [],\n        }\n      )\n\ndef external_subnet(**params):\n    params['ipam_spec'] = _get_ipam_spec(**params)\n    cluster_details = _get_cluster_details(cluster_name=params['cluster_name'])\n    payload = _get_default_spec()\n    if params['uuid'] != \"None\":\n        payload[\"spec\"]['uuid'] = params['uuid']\n    payload[\"spec\"]['name'] = params['name']\n    payload[\"spec\"][\"resources\"][\"subnet_type\"] = \"VLAN\"\n    payload[\"spec\"][\"resources\"][\"vlan_id\"] = params['vlan_id']\n    payload[\"spec\"][\"resources\"][\"ip_config\"] = params['ipam_spec']\n    payload[\"spec\"][\"cluster_reference\"] = cluster_details\n    if params['enable_nat'] == False:\n        switch_details = _get_virtual_switch_uuid(params['virtual_switch_name'])\n        payload[\"spec\"][\"resources\"][\"virtual_switch_uuid\"] = switch_details\n    payload[\"spec\"][\"resources\"][\"is_external\"] = True\n    payload[\"spec\"][\"resources\"][\"enable_nat\"] = params['enable_nat']\n    url = _build_url(scheme=\"https\",\n                        resource_type=\"\/subnets\")\n\n    data = requests.post(url, json=payload,\n                         auth=HTTPBasicAuth(pc_username,pc_password),\n                         timeout=None, verify=False)\n    if data.ok:\n        wait_for_completion(data)\n        print(\"external_subnet_uuid={}\".format(data.json()['metadata']['uuid']))\n    else:\n        print(\"Failed to create External Subnet ---> \",data.json().get('message_list', \n                                        data.json().get('error_detail', data.json())))\n        exit(1)\n\ndef wait_for_completion(data):\n    if data.ok:\n        state = data.json()['status'].get('state')\n        while state == \"PENDING\":\n            _uuid = data.json()['status']['execution_context']['task_uuid']\n            url = _build_url(scheme=\"https\",\n                             resource_type=\"\/tasks\/%s\"%_uuid)\n            responce = requests.get(url, auth=HTTPBasicAuth(pc_username, pc_password), \n                                    verify=False)\n            if responce.json()['status'] in ['PENDING', 'RUNNING','QUEUED']:\n                state = 'PENDING'\n                sleep(5)                \n            elif responce.json()['status'] == 'FAILED':\n                print(\"Got Error ---> \",responce.json().get('message_list', \n                                        responce.json().get('error_detail', responce.json())))\n                state = 'FAILED'\n                exit(1)\n            else:\n                state = \"COMPLETE\"\n\nif @@{create_external_subnet}@@:\n    params_dict = @@{external_subnet_items}@@\n    params = {}\n    params['name'] = params_dict['name']\n    params['uuid'] = params_dict.get('uuid', \"None\")\n    params['enable_nat'] = params_dict.get('enable_nat', False)\n    params['cluster_name'] = params_dict.get('cluster', \"None\")\n    params['vlan_id'] = @@{external_vlan_id}@@\n    params['virtual_switch_name'] = params_dict.get('virtual_switch_name', \"None\")\n    params['ipam'] = {}\n    params['set_ipam'] = \"yes\"\n    params['ipam']['network_ip'] = params_dict.get('network_ip', 'None')\n    params['ipam']['network_prefix'] = params_dict.get('prefix', 'None')\n    params['ipam']['gateway_ip'] = params_dict['gateway_ip']\n    params['ip_pools'] = params_dict['ip_pools']\n    external_subnet(**params)\nelse:\n    subnet = \"@@{external_subnet_name}@@\".strip()\n    print(\"Retriving External subnet details of %s.\"%subnet)\n    url = _build_url(scheme=\"https\",resource_type=\"\/subnets\/list\")\n    data = requests.post(url, json={\"kind\":\"subnet\", \"filter\":\"name==%s\"%subnet},\n                         auth=HTTPBasicAuth(pc_username, \n                                            pc_password),\n                         timeout=None, verify=False)\n    if data.ok:\n        if data.json()['metadata']['total_matches'] == 0:\n            print(\"%s not present on %s\"%(subnet, PC_IP))\n            exit(1)\n        elif data.json()['metadata']['total_matches'] > 1:\n            for _subnet in data.json()['entities']:\n                if \"@@{external_vlan_id}@@\" in str(data.json()):\n                    if _subnet[\"spec\"][\"resources\"][\"vlan_id\"] == @@{external_vlan_id}@@:\n                        print(\"external_subnet_uuid={}\".format(_subnet[\"metadata\"][\"uuid\"]))\n                else:\n                    print(\"Input Error :- %s External Subnet with %s VLAN ID not exist on %s.\"%(\\\n                                                        subnet, \"@@{external_vlan_id}@@\", PC_IP))\n                    exit(1)\n        else:\n            print(\"external_subnet_uuid={}\".format(\\\n                data.json()['entities'][0]['metadata']['uuid']))\n    else:\n        print(\"Error while fetching subnet details :- \",data.json().get('message_list',\n                                     data.json().get('error_detail', data.json())))\n        exit(1)","eval_variables":["external_subnet_uuid"],"eval_scope":"local","type":"","script_type":"static"},"timeout_secs":"0","type":"SET_VARIABLE","variable_list":[]},{"retries":"0","description":"","inherit_target":false,"child_tasks_local_reference_list":[],"name":"Create VPC","attrs":{"exit_status":[],"script":"#script\n\nimport requests\nfrom requests.auth import HTTPBasicAuth\n\nPC_IP = \"@@{PC_IP}@@\".strip()\npc_username = \"@@{prism_central_username}@@\".strip()\npc_password = \"@@{prism_central_passwd}@@\".strip()\n\ndef _build_url(scheme, resource_type, host=PC_IP, **params):\n    _base_url = \"\/api\/nutanix\/v3\"\n    url = \"{proto}:\/\/{host}\".format(proto=scheme, host=host)\n    port = params.get('nutanix_port', '9440')\n    if port:\n        url = url + \":{0}\".format(port) + _base_url\n    if resource_type.startswith(\"\/\"):\n        url += resource_type\n    else:\n        url += \"\/{0}\".format(resource_type)\n    return url\n\ndef _get_default_spec():\n    return(\n            {\n            \"api_version\": \"3.1.0\",\n            \"metadata\": {\"kind\": \"vpc\", \"categories\": {}},\n            \"spec\": {\n                \"name\": None,\n                \"resources\": {\n                    \"external_subnet_list\": []\n                    },\n                },\n            })\n\ndef create_vpc(**params):\n    payload = _get_default_spec()\n    if params['uuid'] != \"None\":\n        payload[\"spec\"]['uuid'] = params['uuid']\n    payload[\"spec\"]['name'] = params['name']\n    if params.get(\"common_domain_name_server_ip_list\", \"None\") != \"None\":\n        payload[\"spec\"][\"resources\"][\"common_domain_name_server_ip_list\"] = \\\n                                params[\"common_domain_name_server_ip_list\"]\n    payload[\"spec\"][\"resources\"][\"external_subnet_list\"] = \\\n                                params[\"external_subnet_list\"]\n    if params.get(\"externally_routable_prefix_list\", \"None\") != \"None\":\n        payload[\"spec\"][\"resources\"][\"externally_routable_prefix_list\"] = \\\n                                params[\"externally_routable_prefix_list\"]\n    url = _build_url(scheme=\"https\",\n                        resource_type=\"\/vpcs\")    \n    data = requests.post(url, json=payload,\n                         auth=HTTPBasicAuth(pc_username, pc_password ),\n                         timeout=None, verify=False)\n                         \n    if not data.ok:\n        print(\"Got Error ---> \",data.json().get('message_list', \n                                data.json().get('error_detail', data.json())))\n        exit(1)\n    else:\n        wait_for_completion(data)\n        vpc_uuid = data.json()['metadata']['uuid']\n        print(\"vpc_uuid={}\".format(vpc_uuid))\n        create_static_route(vpc_uuid)\n        \ndef _get_route_spec(vpc_uuid):\n    subnet_name = \"@@{external_subnet_name}@@\".strip()\n    subnet_uuid = \"@@{external_subnet_uuid}@@\"\n    ip_prefix = \"0.0.0.0\/0\"\n    url = _build_url(scheme=\"https\",\n                    resource_type=\"\/vpcs\/%s\/route_tables\"%vpc_uuid)\n    data = requests.get(url, auth=HTTPBasicAuth(pc_username, pc_password), verify=False)\n    if data.ok:\n        responce = data.json()\n        del responce[\"status\"]\n        for x in [\"last_update_time\",\"creation_time\",\"spec_hash\",\"categories_mapping\",\"owner_reference\",\"categories\"]:\n            if x in responce[\"metadata\"].keys():\n                del responce[\"metadata\"][x]\n    else:\n        print(\"Error while fetching VPCs static route details.\")\n        exit(1)\n    static_route = {\"nexthop\": {\n                        \"external_subnet_reference\": {\n                            \"kind\": \"subnet\",\n                            \"name\": subnet_name,\n                            \"uuid\": subnet_uuid\n                        }\n                    },\n                    \"destination\": ip_prefix}\n    responce[\"spec\"][\"resources\"][\"static_routes_list\"].append(static_route)\n    return responce\n\ndef create_static_route(vpc_uuid):\n    subnet_uuid = \"@@{external_subnet_uuid}@@\"\n    subnet_name = \"@@{external_subnet_name}@@\".strip()\n    payload = _get_route_spec(vpc_uuid)\n    url = _build_url(scheme=\"https\",\n                    resource_type=\"\/vpcs\/%s\/route_tables\"%vpc_uuid)\n    data = requests.put(url, json=payload, \n                        auth=HTTPBasicAuth(pc_username, pc_password), verify=False)\n    wait_for_completion(data)\n    \ndef wait_for_completion(data):\n    if data.status_code in [200, 202]:\n        state = data.json()['status'].get('state')\n        while state == \"PENDING\":\n            _uuid = data.json()['status']['execution_context']['task_uuid']\n            url = _build_url(scheme=\"https\",\n                             resource_type=\"\/tasks\/%s\"%_uuid)\n            responce = requests.get(url, auth=HTTPBasicAuth(pc_username, pc_password), \n                                    verify=False)\n            if responce.json()['status'] in ['PENDING', 'RUNNING', 'QUEUED']:\n                state = 'PENDING'\n                sleep(5)                \n            elif responce.json()['status'] == 'FAILED':\n                print(\"Got Error ---> \",responce.json().get('message_list', \n                                        responce.json().get('error_detail', responce.json())))\n                state = 'FAILED'\n                exit(1)\n            else:\n                state = \"COMPLETE\"\n    else:\n        print(\"Got Error ---> \",data.json().get('message_list', \n                                data.json().get('error_detail', data.json())))\n        exit(1)\n\nif @@{create_vpc}@@:\n    params = {}\n    print(\"##### creating VPC #####\")\n    params_dict = @@{vpc_items}@@\n    params['name'] = params_dict['name']\n    params['uuid'] = params_dict.get('uuid', \"None\")\n    if params_dict.get(\"dns_servers\", \"None\") != \"None\":\n        params[\"common_domain_name_server_ip_list\"] = [{}]\n        params[\"common_domain_name_server_ip_list\"][0]['ip'] = \\\n                                            params_dict.get('dns_servers', 'None')\n    params[\"external_subnet_list\"] = [{}]\n    if params_dict.get(\"externally_routable_ip\", \"None\") != \"None\":\n        params[\"externally_routable_prefix_list\"] = [{}]\n        params[\"externally_routable_prefix_list\"][0][\"ip\"] = \\\n                                            params_dict[\"externally_routable_ip\"]\n        params[\"externally_routable_prefix_list\"][0][\"prefix_length\"] = \\\n                                            params_dict[\"externally_routable_ip_prefix\"]\n                                            \n    if params_dict.get(\"external_subnet_name\", \"None\") != \"None\":\n        params[\"external_subnet_list\"][0][\"external_subnet_reference\"] = {}\n        params[\"external_subnet_list\"][0][\"external_subnet_reference\"][\"kind\"] = \"subnet\"\n        params[\"external_subnet_list\"][0][\"external_subnet_reference\"][\"name\"] = \\\n                                            params_dict[\"external_subnet_name\"]\n        params[\"external_subnet_list\"][0][\"external_subnet_reference\"][\"uuid\"] = \"@@{external_subnet_uuid}@@\"\n                                            \n    if params_dict.get(\"external_subnet_uuid\", \"None\") != \"None\":\n        params[\"external_subnet_list\"][0][\"external_subnet_reference\"][\"uuid\"] = \\\n                                               params_dict['external_subnet_uuid']\n    create_vpc(**params)\n    \nelse:\n    vpc_name = \"@@{vpc_name}@@\".strip()\n    print(\"Retriving VPC details of %s\"%vpc_name)\n    url = _build_url(scheme=\"https\",resource_type=\"\/vpcs\/list\")\n    data = requests.post(url, json={\"kind\":\"vpc\", \"filter\":\"name==%s\"%vpc_name},\n                         auth=HTTPBasicAuth(pc_username, \n                                            pc_password),\n                         timeout=None, verify=False)\n    if data.ok:\n        if data.json()['metadata']['total_matches'] == 0:\n            print(\"%s not present on %s\"%(vpc_name, PC_IP))\n        elif data.json()['metadata']['total_matches'] > 1:\n            print(\"There are more than one VPC's with name - %s on - %s\"%(vpc_name, PC_IP))\n            print(\"Please delete it manually before executing runbook.\")\n            exit(1)\n        else:\n            print(\"vpc_uuid={}\".format(data.json()['entities']\\\n                                       [0]['metadata']['uuid']))\n    else:\n        print(\"Error while fetching VPC details :- \",data.json().get('message_list',\n                                     data.json().get('error_detail', data.json())))\n        exit(1)","eval_variables":["vpc_uuid"],"eval_scope":"local","type":"","script_type":"static"},"timeout_secs":"0","type":"SET_VARIABLE","variable_list":[]},{"retries":"0","description":"","inherit_target":false,"child_tasks_local_reference_list":[],"name":"Create Overlay Subnet","attrs":{"script":"#script\n\nimport requests\nfrom requests.auth import HTTPBasicAuth\n\nPC_IP = \"@@{PC_IP}@@\".strip()\npc_username = \"@@{prism_central_username}@@\".strip()\npc_password = \"@@{prism_central_passwd}@@\".strip()\n\ndef _build_url(scheme, resource_type, host=PC_IP, **params):\n    _base_url = \"\/api\/nutanix\/v3\"\n    url = \"{proto}:\/\/{host}\".format(proto=scheme, host=host)\n    port = params.get('nutanix_port', '9440')\n    if port:\n        url = url + \":{0}\".format(port) + _base_url\n    if resource_type.startswith(\"\/\"):\n        url += resource_type\n    else:\n        url += \"\/{0}\".format(resource_type)\n    return url\n\ndef _get_default_spec():\n    return (\n        {\n          \"api_version\": \"3.1.0\",\n          \"metadata\": {\"kind\": \"subnet\"},\n          \"spec\": {\n                  \"name\": \"\",\n                  \"resources\": {\n                      \"ip_config\": {},\n                      \"subnet_type\": None,\n                      },\n                  },\n              }\n          )\n\ndef _get_ipam_spec(**params):\n    ipam_spec = {}\n    if params['set_ipam'] == 'yes':\n        ipam_spec = _get_default_ipconfig_spec()\n        ipam_config = params[\"ipam\"]\n        ipam_spec[\"subnet_ip\"] = ipam_config[\"network_ip\"]\n        ipam_spec[\"prefix_length\"] = ipam_config[\"network_prefix\"]\n        ipam_spec[\"default_gateway_ip\"] = ipam_config[\"gateway_ip\"]\n        pools = []\n        for ip_pools in params['ip_pool']:\n            pools.append({\"range\": \"%s %s\"%(ip_pools['ip_pools_start_ip'], \n                                            ip_pools['ip_pools_end_ip'])})                                \n        ipam_spec[\"pool_list\"] = pools\n        if \"dhcp_options\" in ipam_config:\n            dhcp_spec = _get_default_dhcp_spec()\n            dhcp_config = ipam_config[\"dhcp_options\"]\n            if dhcp_config['domain_name_server_list'] != 'None': \n                dhcp_spec[\"domain_name_server_list\"] = dhcp_config[\"domain_name_server_list\"]\n            if dhcp_config[\"domain_search_list\"] != 'None':\n                dhcp_spec[\"domain_search_list\"] = dhcp_config[\"domain_search_list\"]\n            if dhcp_config[\"domain_name\"] != 'None':\n                dhcp_spec[\"domain_name\"] = dhcp_config[\"domain_name\"]\n            if dhcp_config[\"boot_file_name\"] != 'None':\n              dhcp_spec[\"boot_file_name\"] = dhcp_config[\"boot_file_name\"]\n            if dhcp_config[\"tftp_server_name\"] != 'None':\n                dhcp_spec[\"tftp_server_name\"] = dhcp_config[\"tftp_server_name\"]\n            ipam_spec[\"dhcp_options\"] = dhcp_spec\n    return ipam_spec\n\ndef _get_default_ipconfig_spec():\n    return (\n        {\n         \"subnet_ip\": None,\n         \"prefix_length\": None,\n         \"default_gateway_ip\": None,\n         \"pool_list\": [],\n        }\n      )\n\ndef _get_default_dhcp_spec():\n    return (\n      {\n        \"domain_name_server_list\": [],\n        \"domain_search_list\": [],\n        \"domain_name\": \"\",\n                \"boot_file_name\": \"\",\n                \"tftp_server_name\": \"\",\n       }\n    )\n\ndef wait_for_completion(data):\n    if data.status_code in [200, 202]:\n        state = data.json()['status'].get('state')\n        while state == \"PENDING\":\n            _uuid = data.json()['status']['execution_context']['task_uuid']\n            url = _build_url(scheme=\"https\",\n                            resource_type=\"\/tasks\/%s\"%_uuid)\n            responce = requests.get(url, auth=HTTPBasicAuth(pc_username, pc_password), \n                                    verify=False)\n            if responce.json()['status'] in ['PENDING', 'RUNNING', 'QUEUED']:\n                state = 'PENDING'\n                sleep(5)                \n            elif responce.json()['status'] == 'FAILED':\n                print(\"Got Error ---> \",responce.json().get('message_list', \n                                        responce.json().get('error_detail', responce.json())))\n                state = 'FAILED'\n                exit(1)\n            else:\n                state = \"COMPLETE\"\n    else:\n        print(\"Got Error ---> \",data.json().get('message_list', \n                                data.json().get('error_detail', data.json())))\n        exit(1)\n                                     \ndef create_overlay_subnet():\n    params = {}\n    print(\"##### Creating Overlay Subnets #####\")\n    params_dict = @@{overlay_subnet_items}@@\n    params['vpc_name'] = params_dict.get('vpc_name', 'None')\n    params['ipam'] = {}\n    params['set_ipam'] = \"yes\"\n    params['ipam']['network_ip'] = params_dict.get('network_ip', 'None')\n    params['ipam']['network_prefix'] = params_dict.get('prefix', 'None')\n    params['ipam']['gateway_ip'] = params_dict.get('gateway_ip', 'None')\n    params['ip_pool'] = params_dict['ip_pool']\n    params['dhcp'] = params_dict.get('dhcp', 'None')\n    params['ipam']['dhcp_options'] = {}\n    params['ipam']['dhcp_options']['domain_name_server_list'] = params_dict.get('dns_servers', 'None')\n    params['ipam']['dhcp_options']['domain_search_list'] = params_dict.get('domain_search', 'None')\n    params['ipam']['dhcp_options']['domain_name'] = params_dict.get('domain_name', 'None')\n    params['ipam']['dhcp_options']['boot_file_name'] = params_dict.get('boot_file', \"None\")\n    params['ipam']['dhcp_options']['tftp_server_name'] = params_dict.get('tftp_server', \"None\")\n            \n    payload = _get_default_spec()\n    if params_dict.get('vpc_name', 'None') != 'None':\n        params['vpc_reference'] = {\"kind\": \"vpc\", \"uuid\": \"@@{vpc_uuid}@@\"}\n        payload[\"spec\"][\"resources\"][\"vpc_reference\"] = params['vpc_reference']\n    payload[\"spec\"]['name'] = params_dict['subnet_name']\n    payload[\"spec\"][\"resources\"][\"subnet_type\"] = \"OVERLAY\"\n            \n    if params_dict.get('network_ip', 'None') != 'None':\n        params['ipam_spec'] = _get_ipam_spec(**params)\n        print(\"Overlay Subnet IP range - %s\"%params['ip_pool'])\n        payload[\"spec\"][\"resources\"][\"ip_config\"] = params['ipam_spec']\n\n\n    url = _build_url(scheme=\"https\",\n                    resource_type=\"\/subnets\")    \n    data = requests.post(url, json=payload,\n                         auth=HTTPBasicAuth(pc_username, pc_password),\n                         timeout=None, verify=False)\n    wait_for_completion(data)\nif @@{create_overlay_subnet}@@:\n    create_overlay_subnet()\nelse:\n    print(\"Not creating Overlay subnet as 'Create Overlay subnet' is False\")","type":"","command_line_args":"","exit_status":[],"script_type":"static"},"timeout_secs":"0","type":"EXEC","variable_list":[]}],"description":"","name":"a4e81cce_runbook","main_task_local_reference":{"kind":"app_task","name":"8ee0af0e_dag"},"variable_list":[{"val_type":"STRING","is_mandatory":true,"description":"Example :- 10.44.46.56","data_type":"BASE","type":"LOCAL","name":"PC_IP","value":"10.42.92.21","label":"PC IP","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":true,"description":"","data_type":"BASE","type":"LOCAL","name":"cluster_name","value":"PHX-POC092","label":"Cluster Name","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":true,"description":"","data_type":"BASE","type":"LOCAL","name":"virtual_switch","value":"vs0","label":"Virtual Switch Name","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":true,"description":"","data_type":"BASE","type":"LOCAL","name":"create_external_subnet","value":"False","label":"Create External Subnet","attrs":{"type":"LOCAL"},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":["True","False"]}},{"regex":{"should_validate":false,"value":"^.*$"},"val_type":"STRING","is_mandatory":true,"description":"","data_type":"BASE","type":"LOCAL","name":"external_subnet_name","value":"nutanix_2_external","label":"External Subnet Name","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"regex":{"should_validate":false,"value":"^[\\d]*$"},"val_type":"INT","is_mandatory":true,"description":"","data_type":"BASE","type":"LOCAL","name":"external_vlan_id","value":"20","label":"External VLAN ID","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":false,"description":"Example :- 10.20.30.0\/24","data_type":"BASE","type":"LOCAL","name":"external_subnet_ip","value":"","label":"External Subnet IP with Prefix","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":false,"description":"Enter Start IP followed by End IP. Example :- 10.20.30.2-10.20.30.10","data_type":"BASE","type":"LOCAL","name":"external_subnet_ip_pool","value":"","label":"External Subnet IP Pool Range","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":false,"description":"Example :- 10.20.30.1","data_type":"BASE","type":"LOCAL","name":"external_subnet_gateway_ip","value":"","label":"External Subnet Gateway IP","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":false,"description":"","data_type":"BASE","type":"LOCAL","name":"external_subnet_nat","value":"True","label":"External Subnet NAT","attrs":{"type":"LOCAL"},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":["True","False"]}},{"regex":{"should_validate":false,"value":"^.*$"},"val_type":"STRING","is_mandatory":true,"description":"","data_type":"BASE","type":"LOCAL","name":"create_vpc","value":"True","label":"Create VPC","attrs":{"type":"LOCAL"},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":["True","False"]}},{"val_type":"STRING","is_mandatory":true,"description":"","data_type":"BASE","type":"LOCAL","name":"vpc_name","value":"nutanix_2_vpc","label":"VPC Name","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":true,"description":"","data_type":"BASE","type":"LOCAL","name":"create_overlay_subnet","value":"False","label":"Create Overlay Subnet","attrs":{"type":"LOCAL"},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":["True","False"]}},{"val_type":"STRING","is_mandatory":true,"description":"","data_type":"BASE","type":"LOCAL","name":"overlay_subnet_name","value":"nutanix_2_overlay","label":"Overlay Subnet Name","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":false,"description":"Example :- 10.10.10.0\/24","data_type":"BASE","type":"LOCAL","name":"overlay_subnet_ip","value":"","label":"Overlay Subnet IP With Prefix","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":false,"description":"","data_type":"BASE","type":"LOCAL","name":"overlay_subnet_gateway_ip","value":"","label":"Overlay Subnet Gateway IP","attrs":{"type":""},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"regex":{"should_validate":false,"value":"^.*$"},"val_type":"STRING","is_mandatory":true,"description":"","data_type":"BASE","type":"SECRET","name":"prism_central_username","value":"TSUv\/f3k2yyM4PPdqRqgRBpVwN\/P\/ZvKGp\/ePdtkw\/MIawWwUQ==:utf-8","label":"Prism Central Username","attrs":{"is_secret_modified":false,"secret_reference":{},"type":"SECRET"},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}},{"val_type":"STRING","is_mandatory":true,"description":"","data_type":"BASE","type":"SECRET","name":"prism_central_passwd","value":"+fCepASUq44c4YVqoCwF+h5SCN6RIOT4yjVliVqx8N4N1w0++IUCyrrGmQ==:utf-8","label":"Prism Central Password","attrs":{"is_secret_modified":false,"secret_reference":{},"type":"SECRET"},"editables":{"value":true},"is_hidden":false,"options":{"type":"PREDEFINED","choices":[]}}]}},"name":"Network Configuration"},"api_version":"3.0","metadata":{"last_update_time":"1666002532614329","kind":"runbook","spec_version":0,"creation_time":"1666002532614329","name":"Network Configuration"}}